// This file is automatically generated. Do not edit manually.

import * as fs from 'node:fs/promises';
import { join, resolve } from 'node:path';
import { parseArgs, type ParseArgsOptionsConfig } from 'node:util';
import { Open } from 'unzipper';
import fetch from 'node-fetch';

const PACKAGE_NAME = "{{ CARGO_MAKE_CRATE_FS_NAME }}";
const PACKAGE_VERSION = "{{ CARGO_MAKE_CRATE_VERSION }}";
const DOWNLOAD_BASE_URL = "{{ CDYLIB_DOWNLOAD_BASE_URL }}";
const OUTPUT_DIR_PATH = resolve("dist/");

type TargetPlatform = ReturnType<typeof targetPlatform>;
function targetPlatform() {
  // ref: https://nodejs.org/api/process.html#processplatform
  switch (process.platform) {
    case 'win32':
      return 'pc-windows-msvc';
    case 'darwin':
      return 'apple-darwin';
    case 'linux':
      return 'unknown-linux-gnu';
    default:
      throw new Error(`Platform ${process.platform} is unsupported.`);
  }
}

type TargetArch = ReturnType<typeof targetArch>;

function targetArch() {
  // ref: https://nodejs.org/api/process.html#processarch
  switch (process.arch) {
    case "arm":
      throw new Error(`Arch arm is unsupported. Build for arm64 / aarch64 instead!`);
    case 'arm64':
      return "aarch64";
    case 'x64':
      return "x86_64";
    default:
      throw new Error(`Arch ${process.arch} is unsupported.`);
  }
}

function generateLibraryName(platform: TargetPlatform) {
  switch (platform) {
    case "windows":
      return `${PACKAGE_NAME}.dll`;
    case "macos":
      return `lib${PACKAGE_NAME}.dylib`;
    case "linux":
      return `lib${PACKAGE_NAME}.so`;
  }
}

function generateLibraryDownloadUrl(
  platform: TargetPlatform,
  arch: TargetArch,
  version: string,
) {
  // ie, https://github.com/livekit/rust-sdks/releases/download/rust-sdks/livekit-ffi@0.12.40/ffi-android-arm64.zip
  const filename = `build-${arch}-${platform}.zip`;
  return `${DOWNLOAD_BASE_URL}@${version}/${filename}`;
}

async function doesFileExist(path: string) {
  try {
    await fs.access(path, fs.constants.F_OK);
    return true;
  } catch {
    return false;
  }
}

async function downloadLib(
  platform: TargetPlatform = targetPlatform(),
  arch: TargetArch = targetArch(),
  version = PACKAGE_VERSION,
  output = OUTPUT_DIR_PATH,
  skipIfExists = false,
) {
  const libName = generateLibraryName(platform);
  const libPath = join(output, libName);

  if (skipIfExists && await doesFileExist(libPath)) {
    console.log("Lib file exists, skipping download.");
    return;
  }
  const downloadUrl = generateLibraryDownloadUrl(platform, arch, version);

  const response = await fetch(downloadUrl);
  if (!response.ok) {
    throw new Error(
      `Error fetching ${downloadUrl}: ${response.status} ${await response.text()}`,
    );
  }
  if (!response.body) {
    throw new Error("Response body was null");
  }

  const zipFile = await Open.buffer(Buffer.from(await response.arrayBuffer()));
  await zipFile.extract({ path: output });

  if (!(await doesFileExist(libPath))) {
    throw new Error(
      `Lib file ${libPath} not found after downloading ${downloadUrl} and unzipping the results!`,
    );
  }
}

if (require.main === module) {
  const options: ParseArgsOptionsConfig = {
    platform: { type: 'string', default: targetPlatform() },
    arch: { type: 'string', default: targetArch() },
    version: { type: 'string', default: PACKAGE_VERSION },
    output: { type: 'string', default: OUTPUT_DIR_PATH },
    skip: { type: 'boolean', short: 's', default: false },
  };
  const { values } = parseArgs({ args: process.argv.slice(2), options });
  downloadLib(
    values.platform,
    values.arch,
    values.version,
    values.output,
    values.skip,
  );
}
