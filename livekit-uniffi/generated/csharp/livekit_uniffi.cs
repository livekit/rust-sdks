// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.10.0+v0.29.4
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;

namespace uniffi.livekit_uniffi;

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer
{
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size)
    {
        return _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                var buffer = _UniFFILib.ffi_livekit_uniffi_rustbuffer_alloc(
                    Convert.ToUInt64(size),
                    ref status
                );
                if (buffer.data == IntPtr.Zero)
                {
                    throw new AllocationException(
                        $"RustBuffer.Alloc() returned null data pointer (size={size})"
                    );
                }
                return buffer;
            }
        );
    }

    public static void Free(RustBuffer buffer)
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_livekit_uniffi_rustbuffer_free(buffer, ref status);
            }
        );
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len))
            );
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes
{
    public int length;
    public IntPtr data;
}

// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType>
{
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value)
    {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try
        {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        }
        catch
        {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf)
    {
        var stream = rbuf.AsStream();
        try
        {
            var item = Read(stream);
            if (stream.HasRemaining())
            {
                throw new InternalException(
                    "junk remaining in buffer after lifting, something is very wrong!!"
                );
            }
            return item;
        }
        finally
        {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType> : FfiConverter<CsType, RustBuffer>
{
    public override CsType Lift(RustBuffer value)
    {
        return LiftFromRustBuffer(value);
    }

    public override RustBuffer Lower(CsType value)
    {
        return LowerIntoRustBuffer(value);
    }
}

// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus
{
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess()
    {
        return code == 0;
    }

    public bool IsError()
    {
        return code == 1;
    }

    public bool IsPanic()
    {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
internal class UniffiException : System.Exception
{
    public UniffiException()
        : base() { }

    public UniffiException(string message)
        : base(message) { }
}

internal class UndeclaredErrorException : UniffiException
{
    public UndeclaredErrorException(string message)
        : base(message) { }
}

internal class PanicException : UniffiException
{
    public PanicException(string message)
        : base(message) { }
}

internal class AllocationException : UniffiException
{
    public AllocationException(string message)
        : base(message) { }
}

internal class InternalException : UniffiException
{
    public InternalException(string message)
        : base(message) { }
}

internal class InvalidEnumException : InternalException
{
    public InvalidEnumException(string message)
        : base(message) { }
}

internal class UniffiContractVersionException : UniffiException
{
    public UniffiContractVersionException(string message)
        : base(message) { }
}

internal class UniffiContractChecksumException : UniffiException
{
    public UniffiContractChecksumException(string message)
        : base(message) { }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E>
    where E : System.Exception
{
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler : CallStatusErrorHandler<UniffiException>
{
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf)
    {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException(
            "library has returned an error not declared in UNIFFI interface file"
        );
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers
{
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(
        CallStatusErrorHandler<E> errorHandler,
        RustCallFunc<U> callback
    )
        where E : UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess())
        {
            return return_value;
        }
        else if (status.IsError())
        {
            throw errorHandler.Lift(status.error_buf);
        }
        else if (status.IsPanic())
        {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0)
            {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            }
            else
            {
                throw new PanicException("Rust panic");
            }
        }
        else
        {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(
        CallStatusErrorHandler<E> errorHandler,
        RustCallAction callback
    )
        where E : UniffiException
    {
        _UniffiHelpers.RustCallWithError(
            errorHandler,
            (ref UniffiRustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback)
    {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback)
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }
}

static class FFIObjectUtil
{
    public static void DisposeAll(params Object?[] list)
    {
        Dispose(list);
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
    private static void Dispose(Object? obj)
    {
        if (obj == null)
        {
            return;
        }

        if (obj is IDisposable disposable)
        {
            disposable.Dispose();
            return;
        }

        var objType = obj.GetType();
        var typeCode = Type.GetTypeCode(objType);
        if (typeCode != TypeCode.Object)
        {
            return;
        }

        var genericArguments = objType.GetGenericArguments();
        if (genericArguments.Length == 0 && !objType.IsArray)
        {
            return;
        }

        if (obj is System.Collections.IDictionary objDictionary)
        {
            //This extra code tests to not call "Dispose" for a Dictionary<something, double>()
            //for all values as "double" and alike doesn't support interface "IDisposable"
            var valuesType = objType.GetGenericArguments()[1];
            var elementValuesTypeCode = Type.GetTypeCode(valuesType);
            if (elementValuesTypeCode != TypeCode.Object)
            {
                return;
            }
            foreach (var value in objDictionary.Values)
            {
                Dispose(value);
            }
        }
        else if (obj is System.Collections.IEnumerable listValues)
        {
            //This extra code tests to not call "Dispose" for a List<int>()
            //for all keys as "int" and alike doesn't support interface "IDisposable"
            var elementType = objType.IsArray ? objType.GetElementType() : genericArguments[0];
            var elementValuesTypeCode = Type.GetTypeCode(elementType);
            if (elementValuesTypeCode != TypeCode.Object)
            {
                return;
            }
            foreach (var value in listValues)
            {
                Dispose(value);
            }
        }
    }
}

// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException : System.Exception
{
    public StreamUnderflowException() { }
}

static class BigEndianStreamExtensions
{
    public static void WriteInt32(this Stream stream, int value, int bytesToWrite = 4)
    {
#if DOTNET_8_0_OR_GREATER
        Span<byte> buffer = stackalloc byte[bytesToWrite];
#else
        byte[] buffer = new byte[bytesToWrite];
#endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static void WriteInt64(this Stream stream, long value)
    {
        int bytesToWrite = 8;
#if DOTNET_8_0_OR_GREATER
        Span<byte> buffer = stackalloc byte[bytesToWrite];
#else
        byte[] buffer = new byte[bytesToWrite];
#endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static uint ReadUint32(this Stream stream, int bytesToRead = 4)
    {
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
        Span<byte> buffer = stackalloc byte[bytesToRead];
        stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        uint result = 0;
        uint digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte] * digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static ulong ReadUInt64(this Stream stream)
    {
        int bytesToRead = 8;
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
        Span<byte> buffer = stackalloc byte[bytesToRead];
        stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        ulong result = 0;
        ulong digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte] * digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static void CheckRemaining(this Stream stream, int length)
    {
        if (stream.Length - stream.Position < length)
        {
            throw new StreamUnderflowException();
        }
    }

    public static void ForEach<T>(this T[] items, Action<T> action)
    {
        foreach (var item in items)
        {
            action(item);
        }
    }
}

class BigEndianStream
{
    Stream stream;

    public BigEndianStream(Stream stream)
    {
        this.stream = stream;
    }

    public bool HasRemaining()
    {
        return (stream.Length - Position) > 0;
    }

    public long Position
    {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] buffer)
    {
#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public void WriteByte(byte value) => stream.WriteInt32(value, bytesToWrite: 1);

    public void WriteSByte(sbyte value) => stream.WriteInt32(value, bytesToWrite: 1);

    public void WriteUShort(ushort value) => stream.WriteInt32(value, bytesToWrite: 2);

    public void WriteShort(short value) => stream.WriteInt32(value, bytesToWrite: 2);

    public void WriteUInt(uint value) => stream.WriteInt32((int)value);

    public void WriteInt(int value) => stream.WriteInt32(value);

    public void WriteULong(ulong value) => stream.WriteInt64((long)value);

    public void WriteLong(long value) => stream.WriteInt64(value);

    public void WriteFloat(float value)
    {
        unsafe
        {
            WriteInt(*((int*)&value));
        }
    }

    public void WriteDouble(double value) =>
        stream.WriteInt64(BitConverter.DoubleToInt64Bits(value));

    public byte[] ReadBytes(int length)
    {
        stream.CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte() => (byte)stream.ReadUint32(bytesToRead: 1);

    public ushort ReadUShort() => (ushort)stream.ReadUint32(bytesToRead: 2);

    public uint ReadUInt() => (uint)stream.ReadUint32(bytesToRead: 4);

    public ulong ReadULong() => stream.ReadUInt64();

    public sbyte ReadSByte() => (sbyte)ReadByte();

    public short ReadShort() => (short)ReadUShort();

    public int ReadInt() => (int)ReadUInt();

    public float ReadFloat()
    {
        unsafe
        {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong() => (long)ReadULong();

    public double ReadDouble() => BitConverter.Int64BitsToDouble(ReadLong());
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.

// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib
{
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(ulong @data, sbyte @pollResult);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(ulong @handle);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(ulong @handle);

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU8 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI8 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU16 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI16 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU32 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI32 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructU64 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructI64 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructF32 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructF64 @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructPointer @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );

    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,
        _UniFFILib.UniffiForeignFutureStructVoid @result
    );

    static _UniFFILib()
    {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
    }

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_livekit_uniffi_fn_func_build_version(
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_livekit_uniffi_fn_func_generate_token(
        RustBuffer @options,
        RustBuffer @credentials,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_livekit_uniffi_fn_func_log_forward_bootstrap(
        RustBuffer @level,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_livekit_uniffi_fn_func_log_forward_receive();

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_livekit_uniffi_fn_func_verify_token(
        RustBuffer @token,
        RustBuffer @credentials,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_livekit_uniffi_rustbuffer_alloc(
        ulong @size,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_livekit_uniffi_rustbuffer_from_bytes(
        ForeignBytes @bytes,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rustbuffer_free(
        RustBuffer @buf,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_livekit_uniffi_rustbuffer_reserve(
        RustBuffer @buf,
        ulong @additional,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_u8(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_u8(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_u8(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern byte ffi_livekit_uniffi_rust_future_complete_u8(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_i8(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_i8(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_i8(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte ffi_livekit_uniffi_rust_future_complete_i8(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_u16(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_u16(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_u16(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort ffi_livekit_uniffi_rust_future_complete_u16(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_i16(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_i16(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_i16(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern short ffi_livekit_uniffi_rust_future_complete_i16(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_u32(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_u32(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_u32(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_livekit_uniffi_rust_future_complete_u32(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_i32(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_i32(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_i32(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ffi_livekit_uniffi_rust_future_complete_i32(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_u64(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_u64(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_u64(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong ffi_livekit_uniffi_rust_future_complete_u64(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_i64(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_i64(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_i64(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern long ffi_livekit_uniffi_rust_future_complete_i64(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_f32(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_f32(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_f32(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern float ffi_livekit_uniffi_rust_future_complete_f32(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_f64(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_f64(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_f64(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern double ffi_livekit_uniffi_rust_future_complete_f64(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_pointer(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_pointer(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_pointer(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr ffi_livekit_uniffi_rust_future_complete_pointer(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_rust_buffer(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_rust_buffer(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_rust_buffer(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_livekit_uniffi_rust_future_complete_rust_buffer(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_poll_void(
        IntPtr @handle,
        IntPtr @callback,
        IntPtr @callbackData
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_cancel_void(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_free_void(IntPtr @handle);

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_livekit_uniffi_rust_future_complete_void(
        IntPtr @handle,
        ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_livekit_uniffi_checksum_func_build_version();

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_livekit_uniffi_checksum_func_generate_token();

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_livekit_uniffi_checksum_func_log_forward_bootstrap();

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_livekit_uniffi_checksum_func_log_forward_receive();

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_livekit_uniffi_checksum_func_verify_token();

    [DllImport("livekit_uniffi", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_livekit_uniffi_uniffi_contract_version();

    static void uniffiCheckContractApiVersion()
    {
        var scaffolding_contract_version = _UniFFILib.ffi_livekit_uniffi_uniffi_contract_version();
        if (29 != scaffolding_contract_version)
        {
            throw new UniffiContractVersionException(
                $"uniffi.livekit_uniffi: uniffi bindings expected version `29`, library returned `{scaffolding_contract_version}`"
            );
        }
    }

    static void uniffiCheckApiChecksums()
    {
        {
            var checksum = _UniFFILib.uniffi_livekit_uniffi_checksum_func_build_version();
            if (checksum != 45072)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.livekit_uniffi: uniffi bindings expected function `uniffi_livekit_uniffi_checksum_func_build_version` checksum `45072`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_livekit_uniffi_checksum_func_generate_token();
            if (checksum != 29823)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.livekit_uniffi: uniffi bindings expected function `uniffi_livekit_uniffi_checksum_func_generate_token` checksum `29823`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_livekit_uniffi_checksum_func_log_forward_bootstrap();
            if (checksum != 28675)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.livekit_uniffi: uniffi bindings expected function `uniffi_livekit_uniffi_checksum_func_log_forward_bootstrap` checksum `28675`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_livekit_uniffi_checksum_func_log_forward_receive();
            if (checksum != 7863)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.livekit_uniffi: uniffi bindings expected function `uniffi_livekit_uniffi_checksum_func_log_forward_receive` checksum `7863`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_livekit_uniffi_checksum_func_verify_token();
            if (checksum != 47517)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.livekit_uniffi: uniffi bindings expected function `uniffi_livekit_uniffi_checksum_func_verify_token` checksum `47517`, library returned `{checksum}`"
                );
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625

class FfiConverterUInt32 : FfiConverter<uint, uint>
{
    public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

    public override uint Lift(uint value)
    {
        return value;
    }

    public override uint Read(BigEndianStream stream)
    {
        return stream.ReadUInt();
    }

    public override uint Lower(uint value)
    {
        return value;
    }

    public override int AllocationSize(uint value)
    {
        return 4;
    }

    public override void Write(uint value, BigEndianStream stream)
    {
        stream.WriteUInt(value);
    }
}

class FfiConverterUInt64 : FfiConverter<ulong, ulong>
{
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value)
    {
        return value;
    }

    public override ulong Read(BigEndianStream stream)
    {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value)
    {
        return value;
    }

    public override int AllocationSize(ulong value)
    {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream)
    {
        stream.WriteULong(value);
    }
}

class FfiConverterBoolean : FfiConverter<bool, sbyte>
{
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value)
    {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream)
    {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value)
    {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value)
    {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream)
    {
        stream.WriteSByte(Lower(value));
    }
}

class FfiConverterString : FfiConverter<string, RustBuffer>
{
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value)
    {
        try
        {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        }
        finally
        {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value)
    {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}

class FfiConverterDuration : FfiConverterRustBuffer<TimeSpan>
{
    public static FfiConverterDuration INSTANCE = new FfiConverterDuration();

    // https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/TimeSpan.cs
    private const uint NanosecondsPerTick = 100;

    public override TimeSpan Read(BigEndianStream stream)
    {
        var seconds = stream.ReadULong();
        var nanoseconds = stream.ReadUInt();
        var ticks = seconds * TimeSpan.TicksPerSecond;
        ticks += nanoseconds / NanosecondsPerTick;
        return new TimeSpan(Convert.ToInt64(ticks));
    }

    public override int AllocationSize(TimeSpan value)
    {
        // 8 bytes for seconds, 4 bytes for nanoseconds
        return 12;
    }

    public override void Write(TimeSpan value, BigEndianStream stream)
    {
        stream.WriteULong(Convert.ToUInt64(value.Ticks / TimeSpan.TicksPerSecond));
        stream.WriteUInt(
            Convert.ToUInt32(value.Ticks % TimeSpan.TicksPerSecond * NanosecondsPerTick)
        );
    }
}

/// <summary>
/// API credentials for access token generation and verification.
/// </summary>
internal record ApiCredentials(string @key, string @secret) { }

class FfiConverterTypeApiCredentials : FfiConverterRustBuffer<ApiCredentials>
{
    public static FfiConverterTypeApiCredentials INSTANCE = new FfiConverterTypeApiCredentials();

    public override ApiCredentials Read(BigEndianStream stream)
    {
        return new ApiCredentials(
            @key: FfiConverterString.INSTANCE.Read(stream),
            @secret: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ApiCredentials value)
    {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@key)
            + FfiConverterString.INSTANCE.AllocationSize(value.@secret);
    }

    public override void Write(ApiCredentials value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@key, stream);
        FfiConverterString.INSTANCE.Write(value.@secret, stream);
    }
}

/// <summary>
/// Claims decoded from a valid access token.
/// </summary>
internal record Claims(
    ulong @exp,
    string @iss,
    ulong @nbf,
    string @sub,
    string @name,
    VideoGrants @video,
    SipGrants @sip,
    string @sha256,
    string @metadata,
    Dictionary<string, string> @attributes,
    string @roomName
) { }

class FfiConverterTypeClaims : FfiConverterRustBuffer<Claims>
{
    public static FfiConverterTypeClaims INSTANCE = new FfiConverterTypeClaims();

    public override Claims Read(BigEndianStream stream)
    {
        return new Claims(
            @exp: FfiConverterUInt64.INSTANCE.Read(stream),
            @iss: FfiConverterString.INSTANCE.Read(stream),
            @nbf: FfiConverterUInt64.INSTANCE.Read(stream),
            @sub: FfiConverterString.INSTANCE.Read(stream),
            @name: FfiConverterString.INSTANCE.Read(stream),
            @video: FfiConverterTypeVideoGrants.INSTANCE.Read(stream),
            @sip: FfiConverterTypeSIPGrants.INSTANCE.Read(stream),
            @sha256: FfiConverterString.INSTANCE.Read(stream),
            @metadata: FfiConverterString.INSTANCE.Read(stream),
            @attributes: FfiConverterDictionaryStringString.INSTANCE.Read(stream),
            @roomName: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Claims value)
    {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@exp)
            + FfiConverterString.INSTANCE.AllocationSize(value.@iss)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@nbf)
            + FfiConverterString.INSTANCE.AllocationSize(value.@sub)
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterTypeVideoGrants.INSTANCE.AllocationSize(value.@video)
            + FfiConverterTypeSIPGrants.INSTANCE.AllocationSize(value.@sip)
            + FfiConverterString.INSTANCE.AllocationSize(value.@sha256)
            + FfiConverterString.INSTANCE.AllocationSize(value.@metadata)
            + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(value.@attributes)
            + FfiConverterString.INSTANCE.AllocationSize(value.@roomName);
    }

    public override void Write(Claims value, BigEndianStream stream)
    {
        FfiConverterUInt64.INSTANCE.Write(value.@exp, stream);
        FfiConverterString.INSTANCE.Write(value.@iss, stream);
        FfiConverterUInt64.INSTANCE.Write(value.@nbf, stream);
        FfiConverterString.INSTANCE.Write(value.@sub, stream);
        FfiConverterString.INSTANCE.Write(value.@name, stream);
        FfiConverterTypeVideoGrants.INSTANCE.Write(value.@video, stream);
        FfiConverterTypeSIPGrants.INSTANCE.Write(value.@sip, stream);
        FfiConverterString.INSTANCE.Write(value.@sha256, stream);
        FfiConverterString.INSTANCE.Write(value.@metadata, stream);
        FfiConverterDictionaryStringString.INSTANCE.Write(value.@attributes, stream);
        FfiConverterString.INSTANCE.Write(value.@roomName, stream);
    }
}

internal record LogForwardEntry(
    LogForwardLevel @level,
    string @target,
    string? @file,
    uint? @line,
    string @message
) { }

class FfiConverterTypeLogForwardEntry : FfiConverterRustBuffer<LogForwardEntry>
{
    public static FfiConverterTypeLogForwardEntry INSTANCE = new FfiConverterTypeLogForwardEntry();

    public override LogForwardEntry Read(BigEndianStream stream)
    {
        return new LogForwardEntry(
            @level: FfiConverterTypeLogForwardLevel.INSTANCE.Read(stream),
            @target: FfiConverterString.INSTANCE.Read(stream),
            @file: FfiConverterOptionalString.INSTANCE.Read(stream),
            @line: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @message: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LogForwardEntry value)
    {
        return 0
            + FfiConverterTypeLogForwardLevel.INSTANCE.AllocationSize(value.@level)
            + FfiConverterString.INSTANCE.AllocationSize(value.@target)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@file)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@line)
            + FfiConverterString.INSTANCE.AllocationSize(value.@message);
    }

    public override void Write(LogForwardEntry value, BigEndianStream stream)
    {
        FfiConverterTypeLogForwardLevel.INSTANCE.Write(value.@level, stream);
        FfiConverterString.INSTANCE.Write(value.@target, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@file, stream);
        FfiConverterOptionalUInt32.INSTANCE.Write(value.@line, stream);
        FfiConverterString.INSTANCE.Write(value.@message, stream);
    }
}

/// <summary>
/// SIP grants
///
/// Maps to the JWT's `sip` field.
/// </summary>
internal record SipGrants(bool @admin, bool @call) { }

class FfiConverterTypeSIPGrants : FfiConverterRustBuffer<SipGrants>
{
    public static FfiConverterTypeSIPGrants INSTANCE = new FfiConverterTypeSIPGrants();

    public override SipGrants Read(BigEndianStream stream)
    {
        return new SipGrants(
            @admin: FfiConverterBoolean.INSTANCE.Read(stream),
            @call: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SipGrants value)
    {
        return 0
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@admin)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@call);
    }

    public override void Write(SipGrants value, BigEndianStream stream)
    {
        FfiConverterBoolean.INSTANCE.Write(value.@admin, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@call, stream);
    }
}

/// <summary>
/// Options used for generating an access token.
///
/// Any fields left empty will use the token generator's defaults.
/// </summary>
internal record TokenOptions(
    TimeSpan? @ttl,
    VideoGrants? @videoGrants,
    SipGrants? @sipGrants,
    string? @identity,
    string? @name,
    string? @metadata,
    Dictionary<string, string>? @attributes,
    string? @sha256,
    string? @roomName
) { }

class FfiConverterTypeTokenOptions : FfiConverterRustBuffer<TokenOptions>
{
    public static FfiConverterTypeTokenOptions INSTANCE = new FfiConverterTypeTokenOptions();

    public override TokenOptions Read(BigEndianStream stream)
    {
        return new TokenOptions(
            @ttl: FfiConverterOptionalDuration.INSTANCE.Read(stream),
            @videoGrants: FfiConverterOptionalTypeVideoGrants.INSTANCE.Read(stream),
            @sipGrants: FfiConverterOptionalTypeSIPGrants.INSTANCE.Read(stream),
            @identity: FfiConverterOptionalString.INSTANCE.Read(stream),
            @name: FfiConverterOptionalString.INSTANCE.Read(stream),
            @metadata: FfiConverterOptionalString.INSTANCE.Read(stream),
            @attributes: FfiConverterOptionalDictionaryStringString.INSTANCE.Read(stream),
            @sha256: FfiConverterOptionalString.INSTANCE.Read(stream),
            @roomName: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenOptions value)
    {
        return 0
            + FfiConverterOptionalDuration.INSTANCE.AllocationSize(value.@ttl)
            + FfiConverterOptionalTypeVideoGrants.INSTANCE.AllocationSize(value.@videoGrants)
            + FfiConverterOptionalTypeSIPGrants.INSTANCE.AllocationSize(value.@sipGrants)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@identity)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@metadata)
            + FfiConverterOptionalDictionaryStringString.INSTANCE.AllocationSize(value.@attributes)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@sha256)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@roomName);
    }

    public override void Write(TokenOptions value, BigEndianStream stream)
    {
        FfiConverterOptionalDuration.INSTANCE.Write(value.@ttl, stream);
        FfiConverterOptionalTypeVideoGrants.INSTANCE.Write(value.@videoGrants, stream);
        FfiConverterOptionalTypeSIPGrants.INSTANCE.Write(value.@sipGrants, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@identity, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@name, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@metadata, stream);
        FfiConverterOptionalDictionaryStringString.INSTANCE.Write(value.@attributes, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@sha256, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@roomName, stream);
    }
}

/// <summary>
/// Room permissions
///
/// Maps to the JWT's `video` field.
/// </summary>
internal record VideoGrants(
    bool @roomCreate,
    bool @roomList,
    bool @roomRecord,
    bool @roomAdmin,
    bool @roomJoin,
    string @room,
    string @destinationRoom,
    bool @canPublish,
    bool @canSubscribe,
    bool @canPublishData,
    string[] @canPublishSources,
    bool @canUpdateOwnMetadata,
    bool @ingressAdmin,
    bool @hidden,
    bool @recorder
) { }

class FfiConverterTypeVideoGrants : FfiConverterRustBuffer<VideoGrants>
{
    public static FfiConverterTypeVideoGrants INSTANCE = new FfiConverterTypeVideoGrants();

    public override VideoGrants Read(BigEndianStream stream)
    {
        return new VideoGrants(
            @roomCreate: FfiConverterBoolean.INSTANCE.Read(stream),
            @roomList: FfiConverterBoolean.INSTANCE.Read(stream),
            @roomRecord: FfiConverterBoolean.INSTANCE.Read(stream),
            @roomAdmin: FfiConverterBoolean.INSTANCE.Read(stream),
            @roomJoin: FfiConverterBoolean.INSTANCE.Read(stream),
            @room: FfiConverterString.INSTANCE.Read(stream),
            @destinationRoom: FfiConverterString.INSTANCE.Read(stream),
            @canPublish: FfiConverterBoolean.INSTANCE.Read(stream),
            @canSubscribe: FfiConverterBoolean.INSTANCE.Read(stream),
            @canPublishData: FfiConverterBoolean.INSTANCE.Read(stream),
            @canPublishSources: FfiConverterSequenceString.INSTANCE.Read(stream),
            @canUpdateOwnMetadata: FfiConverterBoolean.INSTANCE.Read(stream),
            @ingressAdmin: FfiConverterBoolean.INSTANCE.Read(stream),
            @hidden: FfiConverterBoolean.INSTANCE.Read(stream),
            @recorder: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(VideoGrants value)
    {
        return 0
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@roomCreate)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@roomList)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@roomRecord)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@roomAdmin)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@roomJoin)
            + FfiConverterString.INSTANCE.AllocationSize(value.@room)
            + FfiConverterString.INSTANCE.AllocationSize(value.@destinationRoom)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@canPublish)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@canSubscribe)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@canPublishData)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@canPublishSources)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@canUpdateOwnMetadata)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@ingressAdmin)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@hidden)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@recorder);
    }

    public override void Write(VideoGrants value, BigEndianStream stream)
    {
        FfiConverterBoolean.INSTANCE.Write(value.@roomCreate, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@roomList, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@roomRecord, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@roomAdmin, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@roomJoin, stream);
        FfiConverterString.INSTANCE.Write(value.@room, stream);
        FfiConverterString.INSTANCE.Write(value.@destinationRoom, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@canPublish, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@canSubscribe, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@canPublishData, stream);
        FfiConverterSequenceString.INSTANCE.Write(value.@canPublishSources, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@canUpdateOwnMetadata, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@ingressAdmin, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@hidden, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@recorder, stream);
    }
}

/// <summary>
/// An error that can occur during token generation or verification.
/// </summary>
internal class AccessTokenException : UniffiException
{
    AccessTokenException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class InvalidKeys : AccessTokenException
    {
        public InvalidKeys(string message)
            : base(message) { }
    }

    public class InvalidEnv : AccessTokenException
    {
        public InvalidEnv(string message)
            : base(message) { }
    }

    public class InvalidClaims : AccessTokenException
    {
        public InvalidClaims(string message)
            : base(message) { }
    }

    public class Encoding : AccessTokenException
    {
        public Encoding(string message)
            : base(message) { }
    }
}

class FfiConverterTypeAccessTokenError
    : FfiConverterRustBuffer<AccessTokenException>,
        CallStatusErrorHandler<AccessTokenException>
{
    public static FfiConverterTypeAccessTokenError INSTANCE =
        new FfiConverterTypeAccessTokenError();

    public override AccessTokenException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new AccessTokenException.InvalidKeys(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new AccessTokenException.InvalidEnv(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 3:
                return new AccessTokenException.InvalidClaims(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 4:
                return new AccessTokenException.Encoding(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeAccessTokenError.Read()",
                        value
                    )
                );
        }
    }

    public override int AllocationSize(AccessTokenException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(AccessTokenException value, BigEndianStream stream)
    {
        switch (value)
        {
            case AccessTokenException.InvalidKeys:
                stream.WriteInt(1);
                break;
            case AccessTokenException.InvalidEnv:
                stream.WriteInt(2);
                break;
            case AccessTokenException.InvalidClaims:
                stream.WriteInt(3);
                break;
            case AccessTokenException.Encoding:
                stream.WriteInt(4);
                break;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeAccessTokenError.Write()",
                        value
                    )
                );
        }
    }
}

internal enum LogForwardFilter : int
{
    Off,
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

class FfiConverterTypeLogForwardFilter : FfiConverterRustBuffer<LogForwardFilter>
{
    public static FfiConverterTypeLogForwardFilter INSTANCE =
        new FfiConverterTypeLogForwardFilter();

    public override LogForwardFilter Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(LogForwardFilter), value))
        {
            return (LogForwardFilter)value;
        }
        else
        {
            throw new InternalException(
                String.Format(
                    "invalid enum value '{0}' in FfiConverterTypeLogForwardFilter.Read()",
                    value
                )
            );
        }
    }

    public override int AllocationSize(LogForwardFilter value)
    {
        return 4;
    }

    public override void Write(LogForwardFilter value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal enum LogForwardLevel : int
{
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

class FfiConverterTypeLogForwardLevel : FfiConverterRustBuffer<LogForwardLevel>
{
    public static FfiConverterTypeLogForwardLevel INSTANCE = new FfiConverterTypeLogForwardLevel();

    public override LogForwardLevel Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(LogForwardLevel), value))
        {
            return (LogForwardLevel)value;
        }
        else
        {
            throw new InternalException(
                String.Format(
                    "invalid enum value '{0}' in FfiConverterTypeLogForwardLevel.Read()",
                    value
                )
            );
        }
    }

    public override int AllocationSize(LogForwardLevel value)
    {
        return 4;
    }

    public override void Write(LogForwardLevel value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

class FfiConverterOptionalUInt32 : FfiConverterRustBuffer<uint?>
{
    public static FfiConverterOptionalUInt32 INSTANCE = new FfiConverterOptionalUInt32();

    public override uint? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterUInt32.INSTANCE.Read(stream);
    }

    public override int AllocationSize(uint? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterUInt32.INSTANCE.AllocationSize((uint)value);
        }
    }

    public override void Write(uint? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterUInt32.INSTANCE.Write((uint)value, stream);
        }
    }
}

class FfiConverterOptionalString : FfiConverterRustBuffer<string?>
{
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override string? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(string? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
        }
    }

    public override void Write(string? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((string)value, stream);
        }
    }
}

class FfiConverterOptionalDuration : FfiConverterRustBuffer<TimeSpan?>
{
    public static FfiConverterOptionalDuration INSTANCE = new FfiConverterOptionalDuration();

    public override TimeSpan? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterDuration.INSTANCE.Read(stream);
    }

    public override int AllocationSize(TimeSpan? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterDuration.INSTANCE.AllocationSize((TimeSpan)value);
        }
    }

    public override void Write(TimeSpan? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterDuration.INSTANCE.Write((TimeSpan)value, stream);
        }
    }
}

class FfiConverterOptionalTypeApiCredentials : FfiConverterRustBuffer<ApiCredentials?>
{
    public static FfiConverterOptionalTypeApiCredentials INSTANCE =
        new FfiConverterOptionalTypeApiCredentials();

    public override ApiCredentials? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeApiCredentials.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ApiCredentials? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeApiCredentials.INSTANCE.AllocationSize((ApiCredentials)value);
        }
    }

    public override void Write(ApiCredentials? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeApiCredentials.INSTANCE.Write((ApiCredentials)value, stream);
        }
    }
}

class FfiConverterOptionalTypeLogForwardEntry : FfiConverterRustBuffer<LogForwardEntry?>
{
    public static FfiConverterOptionalTypeLogForwardEntry INSTANCE =
        new FfiConverterOptionalTypeLogForwardEntry();

    public override LogForwardEntry? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeLogForwardEntry.INSTANCE.Read(stream);
    }

    public override int AllocationSize(LogForwardEntry? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterTypeLogForwardEntry.INSTANCE.AllocationSize((LogForwardEntry)value);
        }
    }

    public override void Write(LogForwardEntry? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeLogForwardEntry.INSTANCE.Write((LogForwardEntry)value, stream);
        }
    }
}

class FfiConverterOptionalTypeSIPGrants : FfiConverterRustBuffer<SipGrants?>
{
    public static FfiConverterOptionalTypeSIPGrants INSTANCE =
        new FfiConverterOptionalTypeSIPGrants();

    public override SipGrants? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeSIPGrants.INSTANCE.Read(stream);
    }

    public override int AllocationSize(SipGrants? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeSIPGrants.INSTANCE.AllocationSize((SipGrants)value);
        }
    }

    public override void Write(SipGrants? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeSIPGrants.INSTANCE.Write((SipGrants)value, stream);
        }
    }
}

class FfiConverterOptionalTypeVideoGrants : FfiConverterRustBuffer<VideoGrants?>
{
    public static FfiConverterOptionalTypeVideoGrants INSTANCE =
        new FfiConverterOptionalTypeVideoGrants();

    public override VideoGrants? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterTypeVideoGrants.INSTANCE.Read(stream);
    }

    public override int AllocationSize(VideoGrants? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterTypeVideoGrants.INSTANCE.AllocationSize((VideoGrants)value);
        }
    }

    public override void Write(VideoGrants? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterTypeVideoGrants.INSTANCE.Write((VideoGrants)value, stream);
        }
    }
}

class FfiConverterOptionalDictionaryStringString
    : FfiConverterRustBuffer<Dictionary<string, string>?>
{
    public static FfiConverterOptionalDictionaryStringString INSTANCE =
        new FfiConverterOptionalDictionaryStringString();

    public override Dictionary<string, string>? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterDictionaryStringString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Dictionary<string, string>? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1
                + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(
                    (Dictionary<string, string>)value
                );
        }
    }

    public override void Write(Dictionary<string, string>? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterDictionaryStringString.INSTANCE.Write(
                (Dictionary<string, string>)value,
                stream
            );
        }
    }
}

class FfiConverterSequenceString : FfiConverterRustBuffer<string[]>
{
    public static FfiConverterSequenceString INSTANCE = new FfiConverterSequenceString();

    public override string[] Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        if (length == 0)
        {
            return [];
        }

        var result = new string[(length)];
        var readFn = FfiConverterString.INSTANCE.Read;
        for (int i = 0; i < length; i++)
        {
            result[i] = readFn(stream);
        }
        return result;
    }

    public override int AllocationSize(string[] value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterString.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(string[] value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Length);
        var writerFn = FfiConverterString.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}

class FfiConverterDictionaryStringString : FfiConverterRustBuffer<Dictionary<string, string>>
{
    public static FfiConverterDictionaryStringString INSTANCE =
        new FfiConverterDictionaryStringString();

    public override Dictionary<string, string> Read(BigEndianStream stream)
    {
        var len = stream.ReadInt();
        var result = new Dictionary<string, string>(len);
        var readerKey = FfiConverterString.INSTANCE.Read;
        var readerValue = FfiConverterString.INSTANCE.Read;
        for (int i = 0; i < len; i++)
        {
            var key = readerKey(stream);
            var value = readerValue(stream);
            result[key] = value;
        }

        return result;
    }

    public override int AllocationSize(Dictionary<string, string> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var allocationKeySizeFn = FfiConverterString.INSTANCE.AllocationSize;
        var allocationKValueSizeFn = FfiConverterString.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item =>
            allocationKeySizeFn(item.Key) + allocationKValueSizeFn(item.Value)
        );
        return sizeForLength + sizeForItems;
    }

    public override void Write(Dictionary<string, string> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerKey = FfiConverterString.INSTANCE.Write;
        var writerValue = FfiConverterString.INSTANCE.Write;
        foreach (var item in value)
        {
            writerKey(item.Key, stream);
            writerValue(item.Value, stream);
        }
    }
}

class ConcurrentHandleMap<T>
    where T : notnull
{
    Dictionary<ulong, T> map = new Dictionary<ulong, T>();

    Object lock_ = new Object();
    ulong currentHandle = 0;

    public ulong Insert(T obj)
    {
        lock (lock_)
        {
            currentHandle += 1;
            map[currentHandle] = obj;
            return currentHandle;
        }
    }

    public bool TryGet(ulong handle, out T result)
    {
        lock (lock_)
        {
#pragma warning disable 8601 // Possible null reference assignment
            return map.TryGetValue(handle, out result);
#pragma warning restore 8601
        }
    }

    public T Get(ulong handle)
    {
        if (TryGet(handle, out var result))
        {
            return result;
        }
        else
        {
            throw new InternalException("ConcurrentHandleMap: Invalid handle");
        }
    }

    public bool Remove(ulong handle)
    {
        return Remove(handle, out T result);
    }

    public bool Remove(ulong handle, out T result)
    {
        lock (lock_)
        {
            // Possible null reference assignment
#pragma warning disable 8601
            if (map.TryGetValue(handle, out result))
            {
#pragma warning restore 8601
                map.Remove(handle);
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
delegate void UniFfiFutureCallback(IntPtr continuationHandle, byte pollResult);

internal static class _UniFFIAsync
{
    internal const byte UNIFFI_RUST_FUTURE_POLL_READY = 0;

    // internal const byte UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1;

    internal static ConcurrentHandleMap<TaskCompletionSource<byte>> _async_handle_map =
        new ConcurrentHandleMap<TaskCompletionSource<byte>>();
    public static ConcurrentHandleMap<CancellationTokenSource> _foreign_futures_map =
        new ConcurrentHandleMap<CancellationTokenSource>();

    // FFI type for Rust future continuations
    internal class UniffiRustFutureContinuationCallback
    {
        public static UniFfiFutureCallback callback = Callback;

        public static void Callback(IntPtr continuationHandle, byte pollResult)
        {
            if (
                _async_handle_map.Remove(
                    (ulong)continuationHandle.ToInt64(),
                    out TaskCompletionSource<byte> task
                )
            )
            {
                task.SetResult(pollResult);
            }
            else
            {
                throw new InternalException(
                    $"Unable to find continuation handle: {continuationHandle}"
                );
            }
        }
    }

    public class UniffiForeignFutureFreeCallback
    {
        public static _UniFFILib.UniffiForeignFutureFree callback = Callback;

        public static void Callback(ulong handle)
        {
            if (_foreign_futures_map.Remove(handle, out CancellationTokenSource task))
            {
                task.Cancel();
            }
            else
            {
                throw new InternalException($"Unable to find cancellation token: {handle}");
            }
        }
    }

    public delegate F CompleteFuncDelegate<F>(IntPtr ptr, ref UniffiRustCallStatus status);

    public delegate void CompleteActionDelegate(IntPtr ptr, ref UniffiRustCallStatus status);

    private static async Task PollFuture(IntPtr rustFuture, Action<IntPtr, IntPtr, IntPtr> pollFunc)
    {
        byte pollResult;
        do
        {
            var tcs = new TaskCompletionSource<byte>(
                TaskCreationOptions.RunContinuationsAsynchronously
            );
            IntPtr callback = Marshal.GetFunctionPointerForDelegate(
                UniffiRustFutureContinuationCallback.callback
            );
            ulong mapEntry = _async_handle_map.Insert(tcs);
            pollFunc(rustFuture, callback, (IntPtr)mapEntry);
            pollResult = await tcs.Task;
        } while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY);
    }

    public static async Task<T> UniffiRustCallAsync<T, F, E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteFuncDelegate<F> completeFunc,
        Action<IntPtr> freeFunc,
        Func<F, T> liftFunc,
        CallStatusErrorHandler<E> errorHandler
    )
        where E : UniffiException
    {
        try
        {
            await PollFuture(rustFuture, pollFunc);
            var result = _UniffiHelpers.RustCallWithError(
                errorHandler,
                (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status)
            );
            return liftFunc(result);
        }
        finally
        {
            freeFunc(rustFuture);
        }
    }

    public static async Task UniffiRustCallAsync<E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteActionDelegate completeFunc,
        Action<IntPtr> freeFunc,
        CallStatusErrorHandler<E> errorHandler
    )
        where E : UniffiException
    {
        try
        {
            await PollFuture(rustFuture, pollFunc);
            _UniffiHelpers.RustCallWithError(
                errorHandler,
                (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status)
            );
        }
        finally
        {
            freeFunc(rustFuture);
        }
    }
}
#pragma warning restore 8625
internal static class LivekitUniffiMethods
{
    /// <summary>
    /// Returns the version specified in the crate's Cargo.toml.
    /// </summary>
    public static string BuildVersion()
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_livekit_uniffi_fn_func_build_version(ref _status)
            )
        );
    }

    /// <summary>
    /// Generates an access token.
    ///
    /// If `credentials` are omitted, API key and secret will be read from the environment
    /// variables `LIVEKIT_API_KEY` and `LIVEKIT_SECRET` respectively.
    /// </summary>
    /// <exception cref="AccessTokenException"></exception>
    public static string GenerateToken(TokenOptions @options, ApiCredentials? @credentials)
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeAccessTokenError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_livekit_uniffi_fn_func_generate_token(
                        FfiConverterTypeTokenOptions.INSTANCE.Lower(@options),
                        FfiConverterOptionalTypeApiCredentials.INSTANCE.Lower(@credentials),
                        ref _status
                    )
            )
        );
    }

    /// <summary>
    /// Bootstraps log forwarding.
    ///
    /// Generally, you will invoke this once early in program execution. However,
    /// subsequent invocations are allowed to change the log level.
    /// </summary>
    public static void LogForwardBootstrap(LogForwardFilter @level)
    {
        _UniffiHelpers.RustCall(
            (ref UniffiRustCallStatus _status) =>
                _UniFFILib.uniffi_livekit_uniffi_fn_func_log_forward_bootstrap(
                    FfiConverterTypeLogForwardFilter.INSTANCE.Lower(@level),
                    ref _status
                )
        );
    }

    /// <summary>
    /// Asynchronously receives a forwarded log entry.
    ///
    /// Invoke repeatedly to receive log entries as they are produced
    /// until `None` is returned, indicating forwarding has ended. Clients will
    /// likely want to bridge this to the languages's equivalent of an asynchronous stream.
    /// </summary>
    public static async Task<LogForwardEntry?> LogForwardReceive()
    {
        return await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            _UniFFILib.uniffi_livekit_uniffi_fn_func_log_forward_receive(),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) =>
                _UniFFILib.ffi_livekit_uniffi_rust_future_poll_rust_buffer(
                    future,
                    continuation,
                    data
                ),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.ffi_livekit_uniffi_rust_future_complete_rust_buffer(
                    future,
                    ref status
                );
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_livekit_uniffi_rust_future_free_rust_buffer(future),
            // Lift
            (result) => FfiConverterOptionalTypeLogForwardEntry.INSTANCE.Lift(result),
            // Error
            NullCallStatusErrorHandler.INSTANCE
        );
    }

    /// <summary>
    /// Verifies an access token.
    ///
    /// If `credentials` are omitted, API key and secret will be read from the environment
    /// variables `LIVEKIT_API_KEY` and `LIVEKIT_SECRET` respectively.
    /// </summary>
    /// <exception cref="AccessTokenException"></exception>
    public static Claims VerifyToken(string @token, ApiCredentials? @credentials)
    {
        return FfiConverterTypeClaims.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeAccessTokenError.INSTANCE,
                (ref UniffiRustCallStatus _status) =>
                    _UniFFILib.uniffi_livekit_uniffi_fn_func_verify_token(
                        FfiConverterString.INSTANCE.Lower(@token),
                        FfiConverterOptionalTypeApiCredentials.INSTANCE.Lower(@credentials),
                        ref _status
                    )
            )
        );
    }
}
