// Copyright 2025 LiveKit, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";

package livekit.proto;
option csharp_namespace = "LiveKit.Proto";

// Registers a topic for incoming streams to be handled.
// Once registered, the client will receive StreamEvent.Opened events as streams are opened
// matching the registered topic.
message StreamRegisterTopicRequest {
    required uint64 room_handle = 1;
    // Topic to register.
    required string topic = 2;
}
message StreamRegisterTopicResponse {
    optional StreamError error = 1;
}

// Unregisters a topic for incoming streams to be handled.
message StreamUnregisterTopicRequest {
    required uint64 room_handle = 1;
    // Topic to unregister.
    required string topic = 2;
}
message StreamUnregisterTopicResponse {}

// Reads an incoming stream incrementally.
// Client will receive StreamEvent.ChunkReceived events as data arrives.
message StreamReadIncrementalRequest {
    required uint64 local_participant_handle = 1;
    // ID of the stream.
    required string id = 2;
}
message StreamReadIncrementalResponse {}

// Reads an incoming stream in its entirety.
message StreamReadAllRequest {
    required uint64 local_participant_handle = 1;
    // ID of the stream.
    required string id = 2;
}
message StreamReadAllResponse {
    required uint64 async_id = 1;

    oneof result {
        StreamPayload payload = 2;
        StreamError error = 3;
    }
}

// Writes data from an incoming stream to a file as it arrives.
message StreamWriteToFileRequest {
    required uint64 local_participant_handle = 1;

    // ID of the stream.
    required string id = 2;

    // Directory to write the file in (must be writable by the current process).
    required string directory = 3;

    // Name to use for the written file.
    // If not provided, the file's name and extension will be inferred from
    // the stream's info.
    optional string name_override = 4;
}
message StreamWriteToFileResponse {
    required uint64 async_id = 1;

    oneof result {
        // Path the file was written to.
        string file_path = 2;
        StreamError error = 3;
    }
}

// Sends the contents of a file over a data stream.
message StreamSendFileRequest {
    required uint64 local_participant_handle = 1;

    // Options to use for opening the stream.
    required StreamOptions options = 2;

    // Path to the file to send (must be readable by the current process).
    required string file_path = 3;
}
message StreamSendFileResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}

// Sends text over a data stream.
message StreamSendTextRequest {
    required uint64 local_participant_handle = 1;

    // Options to use for opening the stream.
    required StreamOptions options = 2;

    // Text to send.
    required string text = 3;
}
message StreamSendTextResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}


// Opens an outgoing stream.
// Call must be balanced with a StreamCloseRequest.
message StreamOpenRequest {
    required uint64 local_participant_handle = 1;

    // Options to use for opening the stream.
    required StreamOptions options = 2;
}
message StreamOpenResponse {
    oneof result {
        // ID of the opened stream to use for subsequent operations.
        string id = 1;
        StreamError error = 2;
    }
}

// Writes data to an outgoing stream opened with StreamOpenRequest.
message StreamWriteRequest {
    required uint64 local_participant_handle = 1;

    // ID of the stream to write to.
    required string id = 2;

    // Payload to write (type much be consistent with the stream type).
    oneof payload {
        bytes bytes = 3;
        string text = 4;
    }
}
message StreamWriteResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}

// Closes an outgoing stream.
message StreamCloseRequest {
    required uint64 local_participant_handle = 1;

    // ID of the stream to close.
    required string id = 2;
}
message StreamCloseResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}

// FFI Events

message StreamEvent {

    // Stream was opened.
    message Opened {
        // Information about the stream derived from its header.
        required StreamInfo info = 1;

        // Identity of the remote participant that opened the stream.
        required string participant_identity = 2;
    }

    // A chunk was received.
    // This event is only emitted for incremental reads.
    message ChunkReceived {
        // Index of the chunk.
        required uint64 index = 1;

        // Content of the chunk.
        required StreamPayload payload = 2;

        // Overall progress of the stream.
        required StreamProgress progress = 3;
    }

    // A chunk was sent.
    // This event is emitted as chunks are sent for an outgoing stream.
    message ChunkSent {
        // Index of the chunk.
        required uint64 index = 1;

        // Overall progress of the stream.
        required StreamProgress progress = 2;
    }

    // Stream was closed, either as the result of an error or normal completion.
    message Closed {
        // A description of the error that occurred that caused the stream to be closed.
        // This is only present if the stream was not closed normally.
        optional StreamError error = 1;
    }

    required uint64 local_participant_handle = 1;

    // ID of the stream this event pertains to.
    required string id = 2;

    // The kind of event that occurred.
    oneof kind {
        Opened opened = 3;
        ChunkReceived chunk_received = 4;
        ChunkSent chunk_sent = 5;
        Closed closed = 6;
    }
}

// FFI Structures

// Contains a subset of the fields from the stream header.
// Protocol-level fields not relevant to the FFI client are omitted (e.g. encryption info).
message StreamInfo {
    required string stream_id = 1; // unique identifier for this data stream
    required int64 timestamp = 2;  // using int64 for Unix timestamp
    required string mime_type = 3;
    required string topic = 4;
    optional uint64 total_length = 5;  // only populated for finite streams, if it's a stream of unknown size this stays empty
    map<string, string> attributes = 6;  // user defined attributes map that can carry additional info

    oneof content_info {
        TextInfo text_info = 7;
        ByteInfo byte_info = 8;
    }

    message TextInfo {
        enum OperationType {
            CREATE = 0;
            UPDATE = 1;
            DELETE = 2;
            REACTION = 3;
        }

        required OperationType operation_type = 1;
        optional int32 version = 2;  // Optional: Version for updates/edits
        optional string reply_to_stream_id = 3;  // Optional: Reply to specific message
        repeated string attached_stream_ids = 4; // file attachments for text streams
        optional bool generated = 5; // true if the text has been generated by an agent from a participant's audio transcription
    }

    message ByteInfo {
        required string name = 1;
    }
}

// Options to use for opening an outgoing stream.
message StreamOptions {
    // TODO: define stream options.
}

// Progress of a stream.
message StreamProgress {
    // Number of bytes read or written so far.
    required uint64 bytes_processed = 1;

    // Total number of bytes that are expected to be read or written (finite streams only).
    optional uint64 bytes_total = 2;
}

// Data read from or written to a stream.
message StreamPayload {
    oneof content {
        bytes bytes = 1;
        string text = 2;
    }
}

// Error pertaining to a stream.
message StreamError {
    // TODO: make this an enum.
    required string description = 1;
}
