// Copyright 2025 LiveKit, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";

package livekit.proto;
option csharp_namespace = "LiveKit.Proto";

import "handle.proto";

// MARK: - Registration

// Registers a topic for incoming streams to be handled.
// Once registered, the client will receive StreamEvent.Opened events as streams are opened
// matching the registered topic.
message StreamRegisterTopicRequest {

    required uint64 room_handle = 1;

    // Topic to handle.
    required string topic = 2;

    // Kind of stream to handle.
    required StreamKind kind = 3;
}
message StreamRegisterTopicResponse {
    optional StreamError error = 1;
}

// Unregisters a topic for incoming streams to be handled.
message StreamUnregisterTopicRequest {
    required uint64 room_handle = 1;

    // Topic of the handler to unregister.
    required string topic = 2;

    // Kind of handler to unregister.
    required StreamKind kind = 3;
}
message StreamUnregisterTopicResponse {}

// MARK: - Text stream reader

// A reader for an incoming stream.
message OwnedTextStreamReader {
    required FfiOwnedHandle handle = 1;
    required BaseStreamInfo base_info = 2;
    required TextStreamInfo text_info = 3;
}

// Reads an incoming text stream incrementally.
message TextStreamReaderReadIncrementalRequest {
    required uint64 reader_handle = 1;
}
message TextStreamReaderReadIncrementalResponse {}

// Reads an incoming text stream in its entirety.
message TextStreamReaderReadAllRequest {
    required uint64 reader_handle = 1;
}
message TextStreamReaderReadAllResponse {
    required uint64 async_id = 1;

    oneof result {
        string content = 2;
        StreamError error = 3;
    }
}

// MARK: - Byte stream reader

// A reader for an incoming stream.
message OwnedByteStreamReader {
    required FfiOwnedHandle handle = 1;
    required BaseStreamInfo base_info = 2;
    required ByteStreamInfo byte_info = 3;
}

// Reads an incoming byte stream incrementally.
message ByteStreamReaderReadIncrementalRequest {
    required uint64 reader_handle = 1;
}
message ByteStreamReaderReadIncrementalResponse {}

// Reads an incoming byte stream in its entirety.
message ByteStreamReaderReadAllRequest {
    required uint64 reader_handle = 1;
}
message ByteStreamReaderReadAllResponse {
    required uint64 async_id = 1;

    oneof result {
        bytes content = 2;
        StreamError error = 3;
    }
}

// Writes data from an incoming stream to a file as it arrives.
message ByteStreamReaderWriteToFileRequest {
    required uint64 reader_handle = 1;

    // Directory to write the file in (must be writable by the current process).
    required string directory = 3;

    // Name to use for the written file.
    // If not provided, the file's name and extension will be inferred from
    // the stream's info.
    optional string name_override = 4;
}
message ByteStreamReaderWriteToFileResponse {
    required uint64 async_id = 1;

    oneof result {
        // Path the file was written to.
        string file_path = 2;
        StreamError error = 3;
    }
}

// MARK: - Send file

// Sends the contents of a file over a data stream.
message StreamSendFileRequest {
    required uint64 local_participant_handle = 1;

    optional BaseStreamOptions base_options = 2;

    // Path of the file to send (must be readable by the current process).
    required string file_path = 3;
}
message StreamSendFileResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}

// MARK: - Send text

// Sends text over a data stream.
message StreamSendTextRequest {
    required uint64 local_participant_handle = 1;

    optional BaseStreamOptions base_options = 2;
    optional TextStreamOptions text_options = 3;

    // Text to send.
    required string text = 4;
}
message StreamSendTextResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}

// MARK: - Byte stream writer

message OwnedByteStreamWriter {
    required FfiOwnedHandle handle = 1;
    required BaseStreamInfo base_info = 2;
    required ByteStreamInfo byte_info = 3;
}

// Opens an outgoing stream.
// Call must be balanced with a StreamCloseRequest.
message ByteStreamOpenRequest {
    required uint64 local_participant_handle = 1;

    // Options to use for opening the stream.
    required BaseStreamOptions options = 2;
}
message ByteStreamOpenResponse {
    oneof result {
        OwnedByteStreamWriter writer = 1;
        StreamError error = 2;
    }
}

// Writes data to a stream writer.
message ByteStreamWriterWriteRequest {
    required uint64 writer_handle = 1;
    required bytes bytes = 2;
}
message ByteStreamWriterWriteResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}

// Closes a stream writer.
message ByteStreamWriterCloseRequest {
    required uint64 writer_handle = 1;
}
message ByteStreamWriterCloseResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}

// MARK: - Text stream writer

message OwnedTextStreamWriter {
    required FfiOwnedHandle handle = 1;
    required BaseStreamInfo base_info = 2;
    required TextStreamInfo text_info = 3;
}

// Opens an outgoing text stream.
// Call must be balanced with a TextStreamCloseRequest.
message TextStreamOpenRequest {
    required uint64 local_participant_handle = 1;

    required BaseStreamOptions base_options = 2;
    required TextStreamOptions text_options = 3;
}
message TextStreamOpenResponse {
    oneof result {
        OwnedTextStreamWriter writer = 1;
        StreamError error = 2;
    }
}

// Writes text to a text stream writer.
message TextStreamWriterWriteRequest {
    required uint64 writer_handle = 1;
    required string text = 2;
}
message TextStreamWriterWriteResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}

// Closes a text stream writer.
message TextStreamWriterCloseRequest {
    required uint64 writer_handle = 1;
}
message TextStreamWriterCloseResponse {
    required uint64 async_id = 1;
    optional StreamError error = 2;
}

// Events

message StreamEvent {

    message TextStreamOpened {
        required OwnedTextStreamReader reader = 1;
        required string participant_identity = 2;
    }

    message ByteStreamOpened {
        required OwnedByteStreamReader reader = 1;
        required string participant_identity = 2;
    }

    // A text chunk was received.
    // This event is only emitted for incremental reads.
    message TextChunkReceived {
        required uint64 reader_handle = 1;
        required string content = 2;
        required StreamProgress progress = 3;
    }

    // A byte chunk was received.
    // This event is only emitted for incremental reads.
    message ByteChunkReceived {
        required uint64 reader_handle = 1;
        required bytes content = 2;
        required StreamProgress progress = 3;
    }

    // A chunk was sent.
    // This event is emitted as chunks are sent for an outgoing stream.
    message ChunkSent {
        required uint64 writer_handle = 1;

        // Index of the chunk.
        required uint64 index = 2;

        // Overall progress of the stream.
        required StreamProgress progress = 3;
    }

    // Stream was closed, either as the result of an error or normal completion.
    message Closed {
        // A description of the error that occurred that caused the stream to be closed.
        // This is only present if the stream was not closed normally.
        optional StreamError error = 1;
    }

    required uint64 local_participant_handle = 1;

    // ID of the stream this event pertains to.
    required string id = 2;

    // The kind of event that occurred.
    oneof kind {
        TextStreamOpened text_stream_opened = 3;
        ByteStreamOpened byte_stream_opened = 4;
        TextChunkReceived text_chunk_received = 5;
        ByteChunkReceived byte_chunk_received = 6;
        ChunkSent chunk_sent = 7;
        Closed closed = 8;
    }
}

// Structures

// The kind of stream (currently byte or text).
enum StreamKind {
    BYTE = 0;
    TEXT = 1;
}

// Contains a subset of the fields from the stream header.
// Protocol-level fields not relevant to the FFI client are omitted (e.g. encryption info).

message BaseStreamInfo {
    required string stream_id = 1; // unique identifier for this data stream
    required int64 timestamp = 2;  // using int64 for Unix timestamp
    required string mime_type = 3;
    required string topic = 4;
    optional uint64 total_length = 5;  // only populated for finite streams, if it's a stream of unknown size this stays empty
    map<string, string> attributes = 6;  // user defined attributes map that can carry additional info
}
message ByteStreamInfo {
    required string name = 1;
}
message TextStreamInfo {
    enum OperationType {
        CREATE = 0;
        UPDATE = 1;
        DELETE = 2;
        REACTION = 3;
    }

    required OperationType operation_type = 1;
    optional int32 version = 2;  // Optional: Version for updates/edits
    optional string reply_to_stream_id = 3;  // Optional: Reply to specific message
    repeated string attached_stream_ids = 4; // file attachments for text streams
    optional bool generated = 5; // true if the text has been generated by an agent from a participant's audio transcription
}

// Options to use for opening an outgoing stream.
message BaseStreamOptions {
    // TODO: define stream options.
}
message TextStreamOptions {
     // TODO: define stream options.
}
message ByteStreamOptions {
     // TODO: define stream options.
}

// Progress of a stream.
message StreamProgress {
    // Number of bytes read or written so far.
    required uint64 bytes_processed = 1;

    // Total number of bytes that are expected to be read or written (finite streams only).
    optional uint64 bytes_total = 2;
}

// Error pertaining to a stream.
message StreamError {
    // TODO: make this an enum.
    required string description = 1;
}
