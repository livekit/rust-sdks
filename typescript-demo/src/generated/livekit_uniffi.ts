// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import * as wasmBundle from './wasm-bindgen/index.js';
import {
  type UniffiByteArray,
  type UniffiDuration,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterBool,
  FfiConverterDuration,
  FfiConverterInt32,
  FfiConverterMap,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const nativeModule = () => wasmBundle;
const uniffiCaller = new UniffiRustCaller(
  () => new wasmBundle.RustCallStatus()
);

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Returns the version specified in the crate's Cargo.toml.
 */
export function buildVersion(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_livekit_uniffi_fn_func_build_version(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generates an access token.
 *
 * If `credentials` are omitted, API key and secret will be read from the environment
 * variables `LIVEKIT_API_KEY` and `LIVEKIT_SECRET` respectively.

 */
export function generateToken(
  options: TokenOptions,
  credentials: ApiCredentials | undefined
): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeAccessTokenError.lift.bind(
        FfiConverterTypeAccessTokenError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_livekit_uniffi_fn_func_generate_token(
          FfiConverterTypeTokenOptions.lower(options),
          FfiConverterOptionalTypeApiCredentials.lower(credentials),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Bootstraps log forwarding.
 *
 * Call this once early in the processes's execution. Calling more
 * than once will cause a panic.

 */
export function logForwardBootstrap(level: LogForwardFilter): void {
  uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
      nativeModule().ubrn_uniffi_livekit_uniffi_fn_func_log_forward_bootstrap(
        FfiConverterTypeLogForwardFilter.lower(level),
        callStatus
      );
    },
    /*liftString:*/ FfiConverterString.lift
  );
}
/**
 * Asynchronously receives a forwarded log entry.
 *
 * Invoke repeatedly to receive log entries as they are produced
 * until `None` is returned, indicating forwarding has ended. Clients will
 * likely want to bridge this to the languages's equivalent of an asynchronous stream.
 *
 * If log forwarding hasn't been bootstrapped, this will panic.

 */
export async function logForwardReceive(asyncOpts_?: {
  signal: AbortSignal;
}): Promise<LogForwardEntry | undefined> {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_livekit_uniffi_fn_func_log_forward_receive();
      },
      /*pollFunc:*/ nativeModule()
        .ubrn_ffi_livekit_uniffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_livekit_uniffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_livekit_uniffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule()
        .ubrn_ffi_livekit_uniffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterOptionalTypeLogForwardEntry.lift.bind(
        FfiConverterOptionalTypeLogForwardEntry
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
/**
 * Verifies an access token.
 *
 * If `credentials` are omitted, API key and secret will be read from the environment
 * variables `LIVEKIT_API_KEY` and `LIVEKIT_SECRET` respectively.

 */
export function verifyToken(
  token: string,
  credentials: ApiCredentials | undefined
): Claims /*throws*/ {
  return FfiConverterTypeClaims.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeAccessTokenError.lift.bind(
        FfiConverterTypeAccessTokenError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_livekit_uniffi_fn_func_verify_token(
          FfiConverterString.lower(token),
          FfiConverterOptionalTypeApiCredentials.lower(credentials),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

/**
 * API credentials for access token generation and verification.
 */
export type ApiCredentials = {
  key: string;
  secret: string;
};

/**
 * Generated factory for {@link ApiCredentials} record objects.
 */
export const ApiCredentials = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ApiCredentials, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ApiCredentials}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ApiCredentials}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link livekit_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ApiCredentials>,
  });
})();

const FfiConverterTypeApiCredentials = (() => {
  type TypeName = ApiCredentials;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterString.read(from),
        secret: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.key, into);
      FfiConverterString.write(value.secret, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.key) +
        FfiConverterString.allocationSize(value.secret)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Claims decoded from a valid access token.
 */
export type Claims = {
  exp: /*u64*/ bigint;
  iss: string;
  nbf: /*u64*/ bigint;
  sub: string;
  name: string;
  video: VideoGrants;
  sip: SipGrants;
  sha256: string;
  metadata: string;
  attributes: Map<string, string>;
  roomName: string;
};

/**
 * Generated factory for {@link Claims} record objects.
 */
export const Claims = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Claims, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Claims}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Claims}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link livekit_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Claims>,
  });
})();

const FfiConverterTypeClaims = (() => {
  type TypeName = Claims;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        exp: FfiConverterUInt64.read(from),
        iss: FfiConverterString.read(from),
        nbf: FfiConverterUInt64.read(from),
        sub: FfiConverterString.read(from),
        name: FfiConverterString.read(from),
        video: FfiConverterTypeVideoGrants.read(from),
        sip: FfiConverterTypeSIPGrants.read(from),
        sha256: FfiConverterString.read(from),
        metadata: FfiConverterString.read(from),
        attributes: FfiConverterMapStringString.read(from),
        roomName: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.exp, into);
      FfiConverterString.write(value.iss, into);
      FfiConverterUInt64.write(value.nbf, into);
      FfiConverterString.write(value.sub, into);
      FfiConverterString.write(value.name, into);
      FfiConverterTypeVideoGrants.write(value.video, into);
      FfiConverterTypeSIPGrants.write(value.sip, into);
      FfiConverterString.write(value.sha256, into);
      FfiConverterString.write(value.metadata, into);
      FfiConverterMapStringString.write(value.attributes, into);
      FfiConverterString.write(value.roomName, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.exp) +
        FfiConverterString.allocationSize(value.iss) +
        FfiConverterUInt64.allocationSize(value.nbf) +
        FfiConverterString.allocationSize(value.sub) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterTypeVideoGrants.allocationSize(value.video) +
        FfiConverterTypeSIPGrants.allocationSize(value.sip) +
        FfiConverterString.allocationSize(value.sha256) +
        FfiConverterString.allocationSize(value.metadata) +
        FfiConverterMapStringString.allocationSize(value.attributes) +
        FfiConverterString.allocationSize(value.roomName)
      );
    }
  }
  return new FFIConverter();
})();

export type LogForwardEntry = {
  level: LogForwardLevel;
  target: string;
  file: string | undefined;
  line: /*u32*/ number | undefined;
  message: string;
};

/**
 * Generated factory for {@link LogForwardEntry} record objects.
 */
export const LogForwardEntry = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<LogForwardEntry, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link LogForwardEntry}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link LogForwardEntry}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link livekit_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<LogForwardEntry>,
  });
})();

const FfiConverterTypeLogForwardEntry = (() => {
  type TypeName = LogForwardEntry;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        level: FfiConverterTypeLogForwardLevel.read(from),
        target: FfiConverterString.read(from),
        file: FfiConverterOptionalString.read(from),
        line: FfiConverterOptionalUInt32.read(from),
        message: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLogForwardLevel.write(value.level, into);
      FfiConverterString.write(value.target, into);
      FfiConverterOptionalString.write(value.file, into);
      FfiConverterOptionalUInt32.write(value.line, into);
      FfiConverterString.write(value.message, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLogForwardLevel.allocationSize(value.level) +
        FfiConverterString.allocationSize(value.target) +
        FfiConverterOptionalString.allocationSize(value.file) +
        FfiConverterOptionalUInt32.allocationSize(value.line) +
        FfiConverterString.allocationSize(value.message)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * SIP grants
 *
 * Maps to the JWT's `sip` field.

 */
export type SipGrants = {
  admin: boolean;
  call: boolean;
};

/**
 * Generated factory for {@link SipGrants} record objects.
 */
export const SipGrants = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<SipGrants, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SipGrants}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SipGrants}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link livekit_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SipGrants>,
  });
})();

const FfiConverterTypeSIPGrants = (() => {
  type TypeName = SipGrants;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        admin: FfiConverterBool.read(from),
        call: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.admin, into);
      FfiConverterBool.write(value.call, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.admin) +
        FfiConverterBool.allocationSize(value.call)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Options used for generating an access token.
 *
 * Any fields left empty will use the token generator's defaults.

 */
export type TokenOptions = {
  ttl: UniffiDuration | undefined;
  videoGrants: VideoGrants | undefined;
  sipGrants: SipGrants | undefined;
  identity: string | undefined;
  name: string | undefined;
  metadata: string | undefined;
  attributes: Map<string, string> | undefined;
  sha256: string | undefined;
  roomName: string | undefined;
};

/**
 * Generated factory for {@link TokenOptions} record objects.
 */
export const TokenOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TokenOptions, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TokenOptions}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TokenOptions}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link livekit_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TokenOptions>,
  });
})();

const FfiConverterTypeTokenOptions = (() => {
  type TypeName = TokenOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        ttl: FfiConverterOptionalDuration.read(from),
        videoGrants: FfiConverterOptionalTypeVideoGrants.read(from),
        sipGrants: FfiConverterOptionalTypeSIPGrants.read(from),
        identity: FfiConverterOptionalString.read(from),
        name: FfiConverterOptionalString.read(from),
        metadata: FfiConverterOptionalString.read(from),
        attributes: FfiConverterOptionalMapStringString.read(from),
        sha256: FfiConverterOptionalString.read(from),
        roomName: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalDuration.write(value.ttl, into);
      FfiConverterOptionalTypeVideoGrants.write(value.videoGrants, into);
      FfiConverterOptionalTypeSIPGrants.write(value.sipGrants, into);
      FfiConverterOptionalString.write(value.identity, into);
      FfiConverterOptionalString.write(value.name, into);
      FfiConverterOptionalString.write(value.metadata, into);
      FfiConverterOptionalMapStringString.write(value.attributes, into);
      FfiConverterOptionalString.write(value.sha256, into);
      FfiConverterOptionalString.write(value.roomName, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalDuration.allocationSize(value.ttl) +
        FfiConverterOptionalTypeVideoGrants.allocationSize(value.videoGrants) +
        FfiConverterOptionalTypeSIPGrants.allocationSize(value.sipGrants) +
        FfiConverterOptionalString.allocationSize(value.identity) +
        FfiConverterOptionalString.allocationSize(value.name) +
        FfiConverterOptionalString.allocationSize(value.metadata) +
        FfiConverterOptionalMapStringString.allocationSize(value.attributes) +
        FfiConverterOptionalString.allocationSize(value.sha256) +
        FfiConverterOptionalString.allocationSize(value.roomName)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * Room permissions
 *
 * Maps to the JWT's `video` field.
 */
export type VideoGrants = {
  roomCreate: boolean;
  roomList: boolean;
  roomRecord: boolean;
  roomAdmin: boolean;
  roomJoin: boolean;
  room: string;
  destinationRoom: string;
  canPublish: boolean;
  canSubscribe: boolean;
  canPublishData: boolean;
  canPublishSources: Array<string>;
  canUpdateOwnMetadata: boolean;
  ingressAdmin: boolean;
  hidden: boolean;
  recorder: boolean;
};

/**
 * Generated factory for {@link VideoGrants} record objects.
 */
export const VideoGrants = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<VideoGrants, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VideoGrants}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VideoGrants}, with defaults specified
     * in Rust, in the {@link livekit_uniffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link livekit_uniffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VideoGrants>,
  });
})();

const FfiConverterTypeVideoGrants = (() => {
  type TypeName = VideoGrants;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        roomCreate: FfiConverterBool.read(from),
        roomList: FfiConverterBool.read(from),
        roomRecord: FfiConverterBool.read(from),
        roomAdmin: FfiConverterBool.read(from),
        roomJoin: FfiConverterBool.read(from),
        room: FfiConverterString.read(from),
        destinationRoom: FfiConverterString.read(from),
        canPublish: FfiConverterBool.read(from),
        canSubscribe: FfiConverterBool.read(from),
        canPublishData: FfiConverterBool.read(from),
        canPublishSources: FfiConverterArrayString.read(from),
        canUpdateOwnMetadata: FfiConverterBool.read(from),
        ingressAdmin: FfiConverterBool.read(from),
        hidden: FfiConverterBool.read(from),
        recorder: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.roomCreate, into);
      FfiConverterBool.write(value.roomList, into);
      FfiConverterBool.write(value.roomRecord, into);
      FfiConverterBool.write(value.roomAdmin, into);
      FfiConverterBool.write(value.roomJoin, into);
      FfiConverterString.write(value.room, into);
      FfiConverterString.write(value.destinationRoom, into);
      FfiConverterBool.write(value.canPublish, into);
      FfiConverterBool.write(value.canSubscribe, into);
      FfiConverterBool.write(value.canPublishData, into);
      FfiConverterArrayString.write(value.canPublishSources, into);
      FfiConverterBool.write(value.canUpdateOwnMetadata, into);
      FfiConverterBool.write(value.ingressAdmin, into);
      FfiConverterBool.write(value.hidden, into);
      FfiConverterBool.write(value.recorder, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.roomCreate) +
        FfiConverterBool.allocationSize(value.roomList) +
        FfiConverterBool.allocationSize(value.roomRecord) +
        FfiConverterBool.allocationSize(value.roomAdmin) +
        FfiConverterBool.allocationSize(value.roomJoin) +
        FfiConverterString.allocationSize(value.room) +
        FfiConverterString.allocationSize(value.destinationRoom) +
        FfiConverterBool.allocationSize(value.canPublish) +
        FfiConverterBool.allocationSize(value.canSubscribe) +
        FfiConverterBool.allocationSize(value.canPublishData) +
        FfiConverterArrayString.allocationSize(value.canPublishSources) +
        FfiConverterBool.allocationSize(value.canUpdateOwnMetadata) +
        FfiConverterBool.allocationSize(value.ingressAdmin) +
        FfiConverterBool.allocationSize(value.hidden) +
        FfiConverterBool.allocationSize(value.recorder)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = (() => {
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  return {
    stringToBytes: (s: string) => encoder.encode(s),
    bytesToString: (ab: UniffiByteArray) => decoder.decode(ab),
    stringByteLength: (s: string) => encoder.encode(s).byteLength,
  };
})();
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Flat error type: AccessTokenError
export enum AccessTokenError_Tags {
  InvalidKeys = 'InvalidKeys',
  InvalidEnv = 'InvalidEnv',
  InvalidClaims = 'InvalidClaims',
  Encoding = 'Encoding',
}
/**
 * An error that can occur during token generation or verification.
 */
export const AccessTokenError = (() => {
  class InvalidKeys extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'AccessTokenError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = AccessTokenError_Tags.InvalidKeys;

    constructor(message: string) {
      super('AccessTokenError', 'InvalidKeys', message);
    }

    static instanceOf(e: any): e is InvalidKeys {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class InvalidEnv extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'AccessTokenError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = AccessTokenError_Tags.InvalidEnv;

    constructor(message: string) {
      super('AccessTokenError', 'InvalidEnv', message);
    }

    static instanceOf(e: any): e is InvalidEnv {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class InvalidClaims extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'AccessTokenError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = AccessTokenError_Tags.InvalidClaims;

    constructor(message: string) {
      super('AccessTokenError', 'InvalidClaims', message);
    }

    static instanceOf(e: any): e is InvalidClaims {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class Encoding extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'AccessTokenError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = AccessTokenError_Tags.Encoding;

    constructor(message: string) {
      super('AccessTokenError', 'Encoding', message);
    }

    static instanceOf(e: any): e is Encoding {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is AccessTokenError {
    return (e as any)[uniffiTypeNameSymbol] === 'AccessTokenError';
  }
  return {
    InvalidKeys,
    InvalidEnv,
    InvalidClaims,
    Encoding,
    instanceOf,
  };
})();

// Union type for AccessTokenError error type.

/**
 * An error that can occur during token generation or verification.
 */

export type AccessTokenError = InstanceType<
  (typeof AccessTokenError)[keyof Omit<typeof AccessTokenError, 'instanceOf'>]
>;

const FfiConverterTypeAccessTokenError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = AccessTokenError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new AccessTokenError.InvalidKeys(
            FfiConverterString.read(from)
          );

        case 2:
          return new AccessTokenError.InvalidEnv(FfiConverterString.read(from));

        case 3:
          return new AccessTokenError.InvalidClaims(
            FfiConverterString.read(from)
          );

        case 4:
          return new AccessTokenError.Encoding(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum LogForwardFilter {
  Off,
  Error,
  Warn,
  Info,
  Debug,
  Trace,
}

const FfiConverterTypeLogForwardFilter = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LogForwardFilter;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return LogForwardFilter.Off;
        case 2:
          return LogForwardFilter.Error;
        case 3:
          return LogForwardFilter.Warn;
        case 4:
          return LogForwardFilter.Info;
        case 5:
          return LogForwardFilter.Debug;
        case 6:
          return LogForwardFilter.Trace;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case LogForwardFilter.Off:
          return ordinalConverter.write(1, into);
        case LogForwardFilter.Error:
          return ordinalConverter.write(2, into);
        case LogForwardFilter.Warn:
          return ordinalConverter.write(3, into);
        case LogForwardFilter.Info:
          return ordinalConverter.write(4, into);
        case LogForwardFilter.Debug:
          return ordinalConverter.write(5, into);
        case LogForwardFilter.Trace:
          return ordinalConverter.write(6, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum LogForwardLevel {
  Error,
  Warn,
  Info,
  Debug,
  Trace,
}

const FfiConverterTypeLogForwardLevel = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LogForwardLevel;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return LogForwardLevel.Error;
        case 2:
          return LogForwardLevel.Warn;
        case 3:
          return LogForwardLevel.Info;
        case 4:
          return LogForwardLevel.Debug;
        case 5:
          return LogForwardLevel.Trace;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case LogForwardLevel.Error:
          return ordinalConverter.write(1, into);
        case LogForwardLevel.Warn:
          return ordinalConverter.write(2, into);
        case LogForwardLevel.Info:
          return ordinalConverter.write(3, into);
        case LogForwardLevel.Debug:
          return ordinalConverter.write(4, into);
        case LogForwardLevel.Trace:
          return ordinalConverter.write(5, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

// FfiConverter for UniffiDuration | undefined
const FfiConverterOptionalDuration = new FfiConverterOptional(
  FfiConverterDuration
);

// FfiConverter for ApiCredentials | undefined
const FfiConverterOptionalTypeApiCredentials = new FfiConverterOptional(
  FfiConverterTypeApiCredentials
);

// FfiConverter for LogForwardEntry | undefined
const FfiConverterOptionalTypeLogForwardEntry = new FfiConverterOptional(
  FfiConverterTypeLogForwardEntry
);

// FfiConverter for SipGrants | undefined
const FfiConverterOptionalTypeSIPGrants = new FfiConverterOptional(
  FfiConverterTypeSIPGrants
);

// FfiConverter for VideoGrants | undefined
const FfiConverterOptionalTypeVideoGrants = new FfiConverterOptional(
  FfiConverterTypeVideoGrants
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Map<string, string> | undefined
const FfiConverterOptionalMapStringString = new FfiConverterOptional(
  FfiConverterMapStringString
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_livekit_uniffi_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_livekit_uniffi_checksum_func_build_version() !==
    45072
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_livekit_uniffi_checksum_func_build_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_livekit_uniffi_checksum_func_generate_token() !==
    29823
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_livekit_uniffi_checksum_func_generate_token'
    );
  }
  if (
    nativeModule().ubrn_uniffi_livekit_uniffi_checksum_func_log_forward_bootstrap() !==
    14091
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_livekit_uniffi_checksum_func_log_forward_bootstrap'
    );
  }
  if (
    nativeModule().ubrn_uniffi_livekit_uniffi_checksum_func_log_forward_receive() !==
    30685
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_livekit_uniffi_checksum_func_log_forward_receive'
    );
  }
  if (
    nativeModule().ubrn_uniffi_livekit_uniffi_checksum_func_verify_token() !==
    47517
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_livekit_uniffi_checksum_func_verify_token'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAccessTokenError,
    FfiConverterTypeApiCredentials,
    FfiConverterTypeClaims,
    FfiConverterTypeLogForwardEntry,
    FfiConverterTypeLogForwardFilter,
    FfiConverterTypeLogForwardLevel,
    FfiConverterTypeSIPGrants,
    FfiConverterTypeTokenOptions,
    FfiConverterTypeVideoGrants,
  },
});
