// Copyright 2025 LiveKit, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.1 with parameter "target=ts,import_extension=.js"
// @generated from file data_stream.proto (package livekit.proto, syntax proto2)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2 } from "@bufbuild/protobuf";
import { FfiOwnedHandle } from "./handle_pb.js";
import { EncryptionType } from "./e2ee_pb.js";

/**
 * A reader for an incoming stream.
 *
 * @generated from message livekit.proto.OwnedTextStreamReader
 */
export class OwnedTextStreamReader extends Message<OwnedTextStreamReader> {
  /**
   * @generated from field: required livekit.proto.FfiOwnedHandle handle = 1;
   */
  handle?: FfiOwnedHandle;

  /**
   * @generated from field: required livekit.proto.TextStreamInfo info = 2;
   */
  info?: TextStreamInfo;

  constructor(data?: PartialMessage<OwnedTextStreamReader>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.OwnedTextStreamReader";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "handle", kind: "message", T: FfiOwnedHandle, req: true },
    { no: 2, name: "info", kind: "message", T: TextStreamInfo, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OwnedTextStreamReader {
    return new OwnedTextStreamReader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OwnedTextStreamReader {
    return new OwnedTextStreamReader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OwnedTextStreamReader {
    return new OwnedTextStreamReader().fromJsonString(jsonString, options);
  }

  static equals(a: OwnedTextStreamReader | PlainMessage<OwnedTextStreamReader> | undefined, b: OwnedTextStreamReader | PlainMessage<OwnedTextStreamReader> | undefined): boolean {
    return proto2.util.equals(OwnedTextStreamReader, a, b);
  }
}

/**
 * Reads an incoming text stream incrementally.
 *
 * @generated from message livekit.proto.TextStreamReaderReadIncrementalRequest
 */
export class TextStreamReaderReadIncrementalRequest extends Message<TextStreamReaderReadIncrementalRequest> {
  /**
   * @generated from field: required uint64 reader_handle = 1;
   */
  readerHandle?: bigint;

  constructor(data?: PartialMessage<TextStreamReaderReadIncrementalRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamReaderReadIncrementalRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "reader_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamReaderReadIncrementalRequest {
    return new TextStreamReaderReadIncrementalRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamReaderReadIncrementalRequest {
    return new TextStreamReaderReadIncrementalRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamReaderReadIncrementalRequest {
    return new TextStreamReaderReadIncrementalRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamReaderReadIncrementalRequest | PlainMessage<TextStreamReaderReadIncrementalRequest> | undefined, b: TextStreamReaderReadIncrementalRequest | PlainMessage<TextStreamReaderReadIncrementalRequest> | undefined): boolean {
    return proto2.util.equals(TextStreamReaderReadIncrementalRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamReaderReadIncrementalResponse
 */
export class TextStreamReaderReadIncrementalResponse extends Message<TextStreamReaderReadIncrementalResponse> {
  constructor(data?: PartialMessage<TextStreamReaderReadIncrementalResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamReaderReadIncrementalResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamReaderReadIncrementalResponse {
    return new TextStreamReaderReadIncrementalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamReaderReadIncrementalResponse {
    return new TextStreamReaderReadIncrementalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamReaderReadIncrementalResponse {
    return new TextStreamReaderReadIncrementalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamReaderReadIncrementalResponse | PlainMessage<TextStreamReaderReadIncrementalResponse> | undefined, b: TextStreamReaderReadIncrementalResponse | PlainMessage<TextStreamReaderReadIncrementalResponse> | undefined): boolean {
    return proto2.util.equals(TextStreamReaderReadIncrementalResponse, a, b);
  }
}

/**
 * Reads an incoming text stream in its entirety.
 *
 * @generated from message livekit.proto.TextStreamReaderReadAllRequest
 */
export class TextStreamReaderReadAllRequest extends Message<TextStreamReaderReadAllRequest> {
  /**
   * @generated from field: required uint64 reader_handle = 1;
   */
  readerHandle?: bigint;

  constructor(data?: PartialMessage<TextStreamReaderReadAllRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamReaderReadAllRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "reader_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamReaderReadAllRequest {
    return new TextStreamReaderReadAllRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamReaderReadAllRequest {
    return new TextStreamReaderReadAllRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamReaderReadAllRequest {
    return new TextStreamReaderReadAllRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamReaderReadAllRequest | PlainMessage<TextStreamReaderReadAllRequest> | undefined, b: TextStreamReaderReadAllRequest | PlainMessage<TextStreamReaderReadAllRequest> | undefined): boolean {
    return proto2.util.equals(TextStreamReaderReadAllRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamReaderReadAllResponse
 */
export class TextStreamReaderReadAllResponse extends Message<TextStreamReaderReadAllResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<TextStreamReaderReadAllResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamReaderReadAllResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamReaderReadAllResponse {
    return new TextStreamReaderReadAllResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamReaderReadAllResponse {
    return new TextStreamReaderReadAllResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamReaderReadAllResponse {
    return new TextStreamReaderReadAllResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamReaderReadAllResponse | PlainMessage<TextStreamReaderReadAllResponse> | undefined, b: TextStreamReaderReadAllResponse | PlainMessage<TextStreamReaderReadAllResponse> | undefined): boolean {
    return proto2.util.equals(TextStreamReaderReadAllResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamReaderReadAllCallback
 */
export class TextStreamReaderReadAllCallback extends Message<TextStreamReaderReadAllCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from oneof livekit.proto.TextStreamReaderReadAllCallback.result
   */
  result: {
    /**
     * @generated from field: string content = 2;
     */
    value: string;
    case: "content";
  } | {
    /**
     * @generated from field: livekit.proto.StreamError error = 3;
     */
    value: StreamError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TextStreamReaderReadAllCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamReaderReadAllCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: StreamError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamReaderReadAllCallback {
    return new TextStreamReaderReadAllCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamReaderReadAllCallback {
    return new TextStreamReaderReadAllCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamReaderReadAllCallback {
    return new TextStreamReaderReadAllCallback().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamReaderReadAllCallback | PlainMessage<TextStreamReaderReadAllCallback> | undefined, b: TextStreamReaderReadAllCallback | PlainMessage<TextStreamReaderReadAllCallback> | undefined): boolean {
    return proto2.util.equals(TextStreamReaderReadAllCallback, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamReaderEvent
 */
export class TextStreamReaderEvent extends Message<TextStreamReaderEvent> {
  /**
   * @generated from field: required uint64 reader_handle = 1;
   */
  readerHandle?: bigint;

  /**
   * @generated from oneof livekit.proto.TextStreamReaderEvent.detail
   */
  detail: {
    /**
     * @generated from field: livekit.proto.TextStreamReaderChunkReceived chunk_received = 2;
     */
    value: TextStreamReaderChunkReceived;
    case: "chunkReceived";
  } | {
    /**
     * @generated from field: livekit.proto.TextStreamReaderEOS eos = 3;
     */
    value: TextStreamReaderEOS;
    case: "eos";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TextStreamReaderEvent>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamReaderEvent";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "reader_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "chunk_received", kind: "message", T: TextStreamReaderChunkReceived, oneof: "detail" },
    { no: 3, name: "eos", kind: "message", T: TextStreamReaderEOS, oneof: "detail" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamReaderEvent {
    return new TextStreamReaderEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamReaderEvent {
    return new TextStreamReaderEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamReaderEvent {
    return new TextStreamReaderEvent().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamReaderEvent | PlainMessage<TextStreamReaderEvent> | undefined, b: TextStreamReaderEvent | PlainMessage<TextStreamReaderEvent> | undefined): boolean {
    return proto2.util.equals(TextStreamReaderEvent, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamReaderChunkReceived
 */
export class TextStreamReaderChunkReceived extends Message<TextStreamReaderChunkReceived> {
  /**
   * @generated from field: required string content = 1;
   */
  content?: string;

  constructor(data?: PartialMessage<TextStreamReaderChunkReceived>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamReaderChunkReceived";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamReaderChunkReceived {
    return new TextStreamReaderChunkReceived().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamReaderChunkReceived {
    return new TextStreamReaderChunkReceived().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamReaderChunkReceived {
    return new TextStreamReaderChunkReceived().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamReaderChunkReceived | PlainMessage<TextStreamReaderChunkReceived> | undefined, b: TextStreamReaderChunkReceived | PlainMessage<TextStreamReaderChunkReceived> | undefined): boolean {
    return proto2.util.equals(TextStreamReaderChunkReceived, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamReaderEOS
 */
export class TextStreamReaderEOS extends Message<TextStreamReaderEOS> {
  /**
   * @generated from field: optional livekit.proto.StreamError error = 1;
   */
  error?: StreamError;

  constructor(data?: PartialMessage<TextStreamReaderEOS>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamReaderEOS";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "error", kind: "message", T: StreamError, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamReaderEOS {
    return new TextStreamReaderEOS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamReaderEOS {
    return new TextStreamReaderEOS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamReaderEOS {
    return new TextStreamReaderEOS().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamReaderEOS | PlainMessage<TextStreamReaderEOS> | undefined, b: TextStreamReaderEOS | PlainMessage<TextStreamReaderEOS> | undefined): boolean {
    return proto2.util.equals(TextStreamReaderEOS, a, b);
  }
}

/**
 * A reader for an incoming stream.
 *
 * @generated from message livekit.proto.OwnedByteStreamReader
 */
export class OwnedByteStreamReader extends Message<OwnedByteStreamReader> {
  /**
   * @generated from field: required livekit.proto.FfiOwnedHandle handle = 1;
   */
  handle?: FfiOwnedHandle;

  /**
   * @generated from field: required livekit.proto.ByteStreamInfo info = 2;
   */
  info?: ByteStreamInfo;

  constructor(data?: PartialMessage<OwnedByteStreamReader>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.OwnedByteStreamReader";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "handle", kind: "message", T: FfiOwnedHandle, req: true },
    { no: 2, name: "info", kind: "message", T: ByteStreamInfo, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OwnedByteStreamReader {
    return new OwnedByteStreamReader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OwnedByteStreamReader {
    return new OwnedByteStreamReader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OwnedByteStreamReader {
    return new OwnedByteStreamReader().fromJsonString(jsonString, options);
  }

  static equals(a: OwnedByteStreamReader | PlainMessage<OwnedByteStreamReader> | undefined, b: OwnedByteStreamReader | PlainMessage<OwnedByteStreamReader> | undefined): boolean {
    return proto2.util.equals(OwnedByteStreamReader, a, b);
  }
}

/**
 * Reads an incoming byte stream incrementally.
 *
 * @generated from message livekit.proto.ByteStreamReaderReadIncrementalRequest
 */
export class ByteStreamReaderReadIncrementalRequest extends Message<ByteStreamReaderReadIncrementalRequest> {
  /**
   * @generated from field: required uint64 reader_handle = 1;
   */
  readerHandle?: bigint;

  constructor(data?: PartialMessage<ByteStreamReaderReadIncrementalRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderReadIncrementalRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "reader_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderReadIncrementalRequest {
    return new ByteStreamReaderReadIncrementalRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderReadIncrementalRequest {
    return new ByteStreamReaderReadIncrementalRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderReadIncrementalRequest {
    return new ByteStreamReaderReadIncrementalRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderReadIncrementalRequest | PlainMessage<ByteStreamReaderReadIncrementalRequest> | undefined, b: ByteStreamReaderReadIncrementalRequest | PlainMessage<ByteStreamReaderReadIncrementalRequest> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderReadIncrementalRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamReaderReadIncrementalResponse
 */
export class ByteStreamReaderReadIncrementalResponse extends Message<ByteStreamReaderReadIncrementalResponse> {
  constructor(data?: PartialMessage<ByteStreamReaderReadIncrementalResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderReadIncrementalResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderReadIncrementalResponse {
    return new ByteStreamReaderReadIncrementalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderReadIncrementalResponse {
    return new ByteStreamReaderReadIncrementalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderReadIncrementalResponse {
    return new ByteStreamReaderReadIncrementalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderReadIncrementalResponse | PlainMessage<ByteStreamReaderReadIncrementalResponse> | undefined, b: ByteStreamReaderReadIncrementalResponse | PlainMessage<ByteStreamReaderReadIncrementalResponse> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderReadIncrementalResponse, a, b);
  }
}

/**
 * Reads an incoming byte stream in its entirety.
 *
 * @generated from message livekit.proto.ByteStreamReaderReadAllRequest
 */
export class ByteStreamReaderReadAllRequest extends Message<ByteStreamReaderReadAllRequest> {
  /**
   * @generated from field: required uint64 reader_handle = 1;
   */
  readerHandle?: bigint;

  constructor(data?: PartialMessage<ByteStreamReaderReadAllRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderReadAllRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "reader_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderReadAllRequest {
    return new ByteStreamReaderReadAllRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderReadAllRequest {
    return new ByteStreamReaderReadAllRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderReadAllRequest {
    return new ByteStreamReaderReadAllRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderReadAllRequest | PlainMessage<ByteStreamReaderReadAllRequest> | undefined, b: ByteStreamReaderReadAllRequest | PlainMessage<ByteStreamReaderReadAllRequest> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderReadAllRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamReaderReadAllResponse
 */
export class ByteStreamReaderReadAllResponse extends Message<ByteStreamReaderReadAllResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<ByteStreamReaderReadAllResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderReadAllResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderReadAllResponse {
    return new ByteStreamReaderReadAllResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderReadAllResponse {
    return new ByteStreamReaderReadAllResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderReadAllResponse {
    return new ByteStreamReaderReadAllResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderReadAllResponse | PlainMessage<ByteStreamReaderReadAllResponse> | undefined, b: ByteStreamReaderReadAllResponse | PlainMessage<ByteStreamReaderReadAllResponse> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderReadAllResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamReaderReadAllCallback
 */
export class ByteStreamReaderReadAllCallback extends Message<ByteStreamReaderReadAllCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from oneof livekit.proto.ByteStreamReaderReadAllCallback.result
   */
  result: {
    /**
     * @generated from field: bytes content = 2;
     */
    value: Uint8Array;
    case: "content";
  } | {
    /**
     * @generated from field: livekit.proto.StreamError error = 3;
     */
    value: StreamError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ByteStreamReaderReadAllCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderReadAllCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "content", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: StreamError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderReadAllCallback {
    return new ByteStreamReaderReadAllCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderReadAllCallback {
    return new ByteStreamReaderReadAllCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderReadAllCallback {
    return new ByteStreamReaderReadAllCallback().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderReadAllCallback | PlainMessage<ByteStreamReaderReadAllCallback> | undefined, b: ByteStreamReaderReadAllCallback | PlainMessage<ByteStreamReaderReadAllCallback> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderReadAllCallback, a, b);
  }
}

/**
 * Writes data from an incoming stream to a file as it arrives.
 *
 * @generated from message livekit.proto.ByteStreamReaderWriteToFileRequest
 */
export class ByteStreamReaderWriteToFileRequest extends Message<ByteStreamReaderWriteToFileRequest> {
  /**
   * @generated from field: required uint64 reader_handle = 1;
   */
  readerHandle?: bigint;

  /**
   * Directory to write the file in (must be writable by the current process).
   * If not provided, the file will be written to the system's temp directory.
   *
   * @generated from field: optional string directory = 3;
   */
  directory?: string;

  /**
   * Name to use for the written file.
   * If not provided, the file's name and extension will be inferred from
   * the stream's info.
   *
   * @generated from field: optional string name_override = 4;
   */
  nameOverride?: string;

  constructor(data?: PartialMessage<ByteStreamReaderWriteToFileRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderWriteToFileRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "reader_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 3, name: "directory", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "name_override", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderWriteToFileRequest {
    return new ByteStreamReaderWriteToFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderWriteToFileRequest {
    return new ByteStreamReaderWriteToFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderWriteToFileRequest {
    return new ByteStreamReaderWriteToFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderWriteToFileRequest | PlainMessage<ByteStreamReaderWriteToFileRequest> | undefined, b: ByteStreamReaderWriteToFileRequest | PlainMessage<ByteStreamReaderWriteToFileRequest> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderWriteToFileRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamReaderWriteToFileResponse
 */
export class ByteStreamReaderWriteToFileResponse extends Message<ByteStreamReaderWriteToFileResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<ByteStreamReaderWriteToFileResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderWriteToFileResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderWriteToFileResponse {
    return new ByteStreamReaderWriteToFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderWriteToFileResponse {
    return new ByteStreamReaderWriteToFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderWriteToFileResponse {
    return new ByteStreamReaderWriteToFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderWriteToFileResponse | PlainMessage<ByteStreamReaderWriteToFileResponse> | undefined, b: ByteStreamReaderWriteToFileResponse | PlainMessage<ByteStreamReaderWriteToFileResponse> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderWriteToFileResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamReaderWriteToFileCallback
 */
export class ByteStreamReaderWriteToFileCallback extends Message<ByteStreamReaderWriteToFileCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from oneof livekit.proto.ByteStreamReaderWriteToFileCallback.result
   */
  result: {
    /**
     * Path the file was written to.
     *
     * @generated from field: string file_path = 2;
     */
    value: string;
    case: "filePath";
  } | {
    /**
     * @generated from field: livekit.proto.StreamError error = 3;
     */
    value: StreamError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ByteStreamReaderWriteToFileCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderWriteToFileCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "file_path", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: StreamError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderWriteToFileCallback {
    return new ByteStreamReaderWriteToFileCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderWriteToFileCallback {
    return new ByteStreamReaderWriteToFileCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderWriteToFileCallback {
    return new ByteStreamReaderWriteToFileCallback().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderWriteToFileCallback | PlainMessage<ByteStreamReaderWriteToFileCallback> | undefined, b: ByteStreamReaderWriteToFileCallback | PlainMessage<ByteStreamReaderWriteToFileCallback> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderWriteToFileCallback, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamReaderEvent
 */
export class ByteStreamReaderEvent extends Message<ByteStreamReaderEvent> {
  /**
   * @generated from field: required uint64 reader_handle = 1;
   */
  readerHandle?: bigint;

  /**
   * @generated from oneof livekit.proto.ByteStreamReaderEvent.detail
   */
  detail: {
    /**
     * @generated from field: livekit.proto.ByteStreamReaderChunkReceived chunk_received = 2;
     */
    value: ByteStreamReaderChunkReceived;
    case: "chunkReceived";
  } | {
    /**
     * @generated from field: livekit.proto.ByteStreamReaderEOS eos = 3;
     */
    value: ByteStreamReaderEOS;
    case: "eos";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ByteStreamReaderEvent>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderEvent";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "reader_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "chunk_received", kind: "message", T: ByteStreamReaderChunkReceived, oneof: "detail" },
    { no: 3, name: "eos", kind: "message", T: ByteStreamReaderEOS, oneof: "detail" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderEvent {
    return new ByteStreamReaderEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderEvent {
    return new ByteStreamReaderEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderEvent {
    return new ByteStreamReaderEvent().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderEvent | PlainMessage<ByteStreamReaderEvent> | undefined, b: ByteStreamReaderEvent | PlainMessage<ByteStreamReaderEvent> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderEvent, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamReaderChunkReceived
 */
export class ByteStreamReaderChunkReceived extends Message<ByteStreamReaderChunkReceived> {
  /**
   * @generated from field: required bytes content = 1;
   */
  content?: Uint8Array;

  constructor(data?: PartialMessage<ByteStreamReaderChunkReceived>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderChunkReceived";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 12 /* ScalarType.BYTES */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderChunkReceived {
    return new ByteStreamReaderChunkReceived().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderChunkReceived {
    return new ByteStreamReaderChunkReceived().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderChunkReceived {
    return new ByteStreamReaderChunkReceived().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderChunkReceived | PlainMessage<ByteStreamReaderChunkReceived> | undefined, b: ByteStreamReaderChunkReceived | PlainMessage<ByteStreamReaderChunkReceived> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderChunkReceived, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamReaderEOS
 */
export class ByteStreamReaderEOS extends Message<ByteStreamReaderEOS> {
  /**
   * @generated from field: optional livekit.proto.StreamError error = 1;
   */
  error?: StreamError;

  constructor(data?: PartialMessage<ByteStreamReaderEOS>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamReaderEOS";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "error", kind: "message", T: StreamError, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamReaderEOS {
    return new ByteStreamReaderEOS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamReaderEOS {
    return new ByteStreamReaderEOS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamReaderEOS {
    return new ByteStreamReaderEOS().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamReaderEOS | PlainMessage<ByteStreamReaderEOS> | undefined, b: ByteStreamReaderEOS | PlainMessage<ByteStreamReaderEOS> | undefined): boolean {
    return proto2.util.equals(ByteStreamReaderEOS, a, b);
  }
}

/**
 * Sends the contents of a file over a data stream.
 *
 * @generated from message livekit.proto.StreamSendFileRequest
 */
export class StreamSendFileRequest extends Message<StreamSendFileRequest> {
  /**
   * @generated from field: required uint64 local_participant_handle = 1;
   */
  localParticipantHandle?: bigint;

  /**
   * @generated from field: required livekit.proto.StreamByteOptions options = 2;
   */
  options?: StreamByteOptions;

  /**
   * Path of the file to send (must be readable by the current process).
   *
   * @generated from field: required string file_path = 3;
   */
  filePath?: string;

  constructor(data?: PartialMessage<StreamSendFileRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamSendFileRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "local_participant_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "options", kind: "message", T: StreamByteOptions, req: true },
    { no: 3, name: "file_path", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSendFileRequest {
    return new StreamSendFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSendFileRequest {
    return new StreamSendFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSendFileRequest {
    return new StreamSendFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSendFileRequest | PlainMessage<StreamSendFileRequest> | undefined, b: StreamSendFileRequest | PlainMessage<StreamSendFileRequest> | undefined): boolean {
    return proto2.util.equals(StreamSendFileRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.StreamSendFileResponse
 */
export class StreamSendFileResponse extends Message<StreamSendFileResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<StreamSendFileResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamSendFileResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSendFileResponse {
    return new StreamSendFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSendFileResponse {
    return new StreamSendFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSendFileResponse {
    return new StreamSendFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSendFileResponse | PlainMessage<StreamSendFileResponse> | undefined, b: StreamSendFileResponse | PlainMessage<StreamSendFileResponse> | undefined): boolean {
    return proto2.util.equals(StreamSendFileResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.StreamSendFileCallback
 */
export class StreamSendFileCallback extends Message<StreamSendFileCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from oneof livekit.proto.StreamSendFileCallback.result
   */
  result: {
    /**
     * @generated from field: livekit.proto.ByteStreamInfo info = 2;
     */
    value: ByteStreamInfo;
    case: "info";
  } | {
    /**
     * @generated from field: livekit.proto.StreamError error = 3;
     */
    value: StreamError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamSendFileCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamSendFileCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "info", kind: "message", T: ByteStreamInfo, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: StreamError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSendFileCallback {
    return new StreamSendFileCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSendFileCallback {
    return new StreamSendFileCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSendFileCallback {
    return new StreamSendFileCallback().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSendFileCallback | PlainMessage<StreamSendFileCallback> | undefined, b: StreamSendFileCallback | PlainMessage<StreamSendFileCallback> | undefined): boolean {
    return proto2.util.equals(StreamSendFileCallback, a, b);
  }
}

/**
 * Sends bytes over a data stream.
 *
 * @generated from message livekit.proto.StreamSendBytesRequest
 */
export class StreamSendBytesRequest extends Message<StreamSendBytesRequest> {
  /**
   * @generated from field: required uint64 local_participant_handle = 1;
   */
  localParticipantHandle?: bigint;

  /**
   * @generated from field: required livekit.proto.StreamByteOptions options = 2;
   */
  options?: StreamByteOptions;

  /**
   * Bytes to send.
   *
   * @generated from field: required bytes bytes = 3;
   */
  bytes?: Uint8Array;

  constructor(data?: PartialMessage<StreamSendBytesRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamSendBytesRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "local_participant_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "options", kind: "message", T: StreamByteOptions, req: true },
    { no: 3, name: "bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSendBytesRequest {
    return new StreamSendBytesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSendBytesRequest {
    return new StreamSendBytesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSendBytesRequest {
    return new StreamSendBytesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSendBytesRequest | PlainMessage<StreamSendBytesRequest> | undefined, b: StreamSendBytesRequest | PlainMessage<StreamSendBytesRequest> | undefined): boolean {
    return proto2.util.equals(StreamSendBytesRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.StreamSendBytesResponse
 */
export class StreamSendBytesResponse extends Message<StreamSendBytesResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<StreamSendBytesResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamSendBytesResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSendBytesResponse {
    return new StreamSendBytesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSendBytesResponse {
    return new StreamSendBytesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSendBytesResponse {
    return new StreamSendBytesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSendBytesResponse | PlainMessage<StreamSendBytesResponse> | undefined, b: StreamSendBytesResponse | PlainMessage<StreamSendBytesResponse> | undefined): boolean {
    return proto2.util.equals(StreamSendBytesResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.StreamSendBytesCallback
 */
export class StreamSendBytesCallback extends Message<StreamSendBytesCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from oneof livekit.proto.StreamSendBytesCallback.result
   */
  result: {
    /**
     * @generated from field: livekit.proto.ByteStreamInfo info = 2;
     */
    value: ByteStreamInfo;
    case: "info";
  } | {
    /**
     * @generated from field: livekit.proto.StreamError error = 3;
     */
    value: StreamError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamSendBytesCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamSendBytesCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "info", kind: "message", T: ByteStreamInfo, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: StreamError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSendBytesCallback {
    return new StreamSendBytesCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSendBytesCallback {
    return new StreamSendBytesCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSendBytesCallback {
    return new StreamSendBytesCallback().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSendBytesCallback | PlainMessage<StreamSendBytesCallback> | undefined, b: StreamSendBytesCallback | PlainMessage<StreamSendBytesCallback> | undefined): boolean {
    return proto2.util.equals(StreamSendBytesCallback, a, b);
  }
}

/**
 * Sends text over a data stream.
 *
 * @generated from message livekit.proto.StreamSendTextRequest
 */
export class StreamSendTextRequest extends Message<StreamSendTextRequest> {
  /**
   * @generated from field: required uint64 local_participant_handle = 1;
   */
  localParticipantHandle?: bigint;

  /**
   * @generated from field: required livekit.proto.StreamTextOptions options = 2;
   */
  options?: StreamTextOptions;

  /**
   * Text to send.
   *
   * @generated from field: required string text = 3;
   */
  text?: string;

  constructor(data?: PartialMessage<StreamSendTextRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamSendTextRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "local_participant_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "options", kind: "message", T: StreamTextOptions, req: true },
    { no: 3, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSendTextRequest {
    return new StreamSendTextRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSendTextRequest {
    return new StreamSendTextRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSendTextRequest {
    return new StreamSendTextRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSendTextRequest | PlainMessage<StreamSendTextRequest> | undefined, b: StreamSendTextRequest | PlainMessage<StreamSendTextRequest> | undefined): boolean {
    return proto2.util.equals(StreamSendTextRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.StreamSendTextResponse
 */
export class StreamSendTextResponse extends Message<StreamSendTextResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<StreamSendTextResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamSendTextResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSendTextResponse {
    return new StreamSendTextResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSendTextResponse {
    return new StreamSendTextResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSendTextResponse {
    return new StreamSendTextResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSendTextResponse | PlainMessage<StreamSendTextResponse> | undefined, b: StreamSendTextResponse | PlainMessage<StreamSendTextResponse> | undefined): boolean {
    return proto2.util.equals(StreamSendTextResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.StreamSendTextCallback
 */
export class StreamSendTextCallback extends Message<StreamSendTextCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from oneof livekit.proto.StreamSendTextCallback.result
   */
  result: {
    /**
     * @generated from field: livekit.proto.TextStreamInfo info = 2;
     */
    value: TextStreamInfo;
    case: "info";
  } | {
    /**
     * @generated from field: livekit.proto.StreamError error = 3;
     */
    value: StreamError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamSendTextCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamSendTextCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "info", kind: "message", T: TextStreamInfo, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: StreamError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSendTextCallback {
    return new StreamSendTextCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSendTextCallback {
    return new StreamSendTextCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSendTextCallback {
    return new StreamSendTextCallback().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSendTextCallback | PlainMessage<StreamSendTextCallback> | undefined, b: StreamSendTextCallback | PlainMessage<StreamSendTextCallback> | undefined): boolean {
    return proto2.util.equals(StreamSendTextCallback, a, b);
  }
}

/**
 * @generated from message livekit.proto.OwnedByteStreamWriter
 */
export class OwnedByteStreamWriter extends Message<OwnedByteStreamWriter> {
  /**
   * @generated from field: required livekit.proto.FfiOwnedHandle handle = 1;
   */
  handle?: FfiOwnedHandle;

  /**
   * @generated from field: required livekit.proto.ByteStreamInfo info = 2;
   */
  info?: ByteStreamInfo;

  constructor(data?: PartialMessage<OwnedByteStreamWriter>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.OwnedByteStreamWriter";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "handle", kind: "message", T: FfiOwnedHandle, req: true },
    { no: 2, name: "info", kind: "message", T: ByteStreamInfo, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OwnedByteStreamWriter {
    return new OwnedByteStreamWriter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OwnedByteStreamWriter {
    return new OwnedByteStreamWriter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OwnedByteStreamWriter {
    return new OwnedByteStreamWriter().fromJsonString(jsonString, options);
  }

  static equals(a: OwnedByteStreamWriter | PlainMessage<OwnedByteStreamWriter> | undefined, b: OwnedByteStreamWriter | PlainMessage<OwnedByteStreamWriter> | undefined): boolean {
    return proto2.util.equals(OwnedByteStreamWriter, a, b);
  }
}

/**
 * Opens an outgoing stream.
 * Call must be balanced with a StreamCloseRequest.
 *
 * @generated from message livekit.proto.ByteStreamOpenRequest
 */
export class ByteStreamOpenRequest extends Message<ByteStreamOpenRequest> {
  /**
   * @generated from field: required uint64 local_participant_handle = 1;
   */
  localParticipantHandle?: bigint;

  /**
   * Options to use for opening the stream.
   *
   * @generated from field: required livekit.proto.StreamByteOptions options = 2;
   */
  options?: StreamByteOptions;

  constructor(data?: PartialMessage<ByteStreamOpenRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamOpenRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "local_participant_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "options", kind: "message", T: StreamByteOptions, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamOpenRequest {
    return new ByteStreamOpenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamOpenRequest {
    return new ByteStreamOpenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamOpenRequest {
    return new ByteStreamOpenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamOpenRequest | PlainMessage<ByteStreamOpenRequest> | undefined, b: ByteStreamOpenRequest | PlainMessage<ByteStreamOpenRequest> | undefined): boolean {
    return proto2.util.equals(ByteStreamOpenRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamOpenResponse
 */
export class ByteStreamOpenResponse extends Message<ByteStreamOpenResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<ByteStreamOpenResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamOpenResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamOpenResponse {
    return new ByteStreamOpenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamOpenResponse {
    return new ByteStreamOpenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamOpenResponse {
    return new ByteStreamOpenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamOpenResponse | PlainMessage<ByteStreamOpenResponse> | undefined, b: ByteStreamOpenResponse | PlainMessage<ByteStreamOpenResponse> | undefined): boolean {
    return proto2.util.equals(ByteStreamOpenResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamOpenCallback
 */
export class ByteStreamOpenCallback extends Message<ByteStreamOpenCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from oneof livekit.proto.ByteStreamOpenCallback.result
   */
  result: {
    /**
     * @generated from field: livekit.proto.OwnedByteStreamWriter writer = 2;
     */
    value: OwnedByteStreamWriter;
    case: "writer";
  } | {
    /**
     * @generated from field: livekit.proto.StreamError error = 3;
     */
    value: StreamError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ByteStreamOpenCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamOpenCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "writer", kind: "message", T: OwnedByteStreamWriter, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: StreamError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamOpenCallback {
    return new ByteStreamOpenCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamOpenCallback {
    return new ByteStreamOpenCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamOpenCallback {
    return new ByteStreamOpenCallback().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamOpenCallback | PlainMessage<ByteStreamOpenCallback> | undefined, b: ByteStreamOpenCallback | PlainMessage<ByteStreamOpenCallback> | undefined): boolean {
    return proto2.util.equals(ByteStreamOpenCallback, a, b);
  }
}

/**
 * Writes data to a stream writer.
 *
 * @generated from message livekit.proto.ByteStreamWriterWriteRequest
 */
export class ByteStreamWriterWriteRequest extends Message<ByteStreamWriterWriteRequest> {
  /**
   * @generated from field: required uint64 writer_handle = 1;
   */
  writerHandle?: bigint;

  /**
   * @generated from field: required bytes bytes = 2;
   */
  bytes?: Uint8Array;

  constructor(data?: PartialMessage<ByteStreamWriterWriteRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamWriterWriteRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "writer_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamWriterWriteRequest {
    return new ByteStreamWriterWriteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamWriterWriteRequest {
    return new ByteStreamWriterWriteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamWriterWriteRequest {
    return new ByteStreamWriterWriteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamWriterWriteRequest | PlainMessage<ByteStreamWriterWriteRequest> | undefined, b: ByteStreamWriterWriteRequest | PlainMessage<ByteStreamWriterWriteRequest> | undefined): boolean {
    return proto2.util.equals(ByteStreamWriterWriteRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamWriterWriteResponse
 */
export class ByteStreamWriterWriteResponse extends Message<ByteStreamWriterWriteResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<ByteStreamWriterWriteResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamWriterWriteResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamWriterWriteResponse {
    return new ByteStreamWriterWriteResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamWriterWriteResponse {
    return new ByteStreamWriterWriteResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamWriterWriteResponse {
    return new ByteStreamWriterWriteResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamWriterWriteResponse | PlainMessage<ByteStreamWriterWriteResponse> | undefined, b: ByteStreamWriterWriteResponse | PlainMessage<ByteStreamWriterWriteResponse> | undefined): boolean {
    return proto2.util.equals(ByteStreamWriterWriteResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamWriterWriteCallback
 */
export class ByteStreamWriterWriteCallback extends Message<ByteStreamWriterWriteCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from field: optional livekit.proto.StreamError error = 2;
   */
  error?: StreamError;

  constructor(data?: PartialMessage<ByteStreamWriterWriteCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamWriterWriteCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "error", kind: "message", T: StreamError, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamWriterWriteCallback {
    return new ByteStreamWriterWriteCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamWriterWriteCallback {
    return new ByteStreamWriterWriteCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamWriterWriteCallback {
    return new ByteStreamWriterWriteCallback().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamWriterWriteCallback | PlainMessage<ByteStreamWriterWriteCallback> | undefined, b: ByteStreamWriterWriteCallback | PlainMessage<ByteStreamWriterWriteCallback> | undefined): boolean {
    return proto2.util.equals(ByteStreamWriterWriteCallback, a, b);
  }
}

/**
 * Closes a stream writer.
 *
 * @generated from message livekit.proto.ByteStreamWriterCloseRequest
 */
export class ByteStreamWriterCloseRequest extends Message<ByteStreamWriterCloseRequest> {
  /**
   * @generated from field: required uint64 writer_handle = 1;
   */
  writerHandle?: bigint;

  /**
   * @generated from field: optional string reason = 2;
   */
  reason?: string;

  constructor(data?: PartialMessage<ByteStreamWriterCloseRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamWriterCloseRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "writer_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamWriterCloseRequest {
    return new ByteStreamWriterCloseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamWriterCloseRequest {
    return new ByteStreamWriterCloseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamWriterCloseRequest {
    return new ByteStreamWriterCloseRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamWriterCloseRequest | PlainMessage<ByteStreamWriterCloseRequest> | undefined, b: ByteStreamWriterCloseRequest | PlainMessage<ByteStreamWriterCloseRequest> | undefined): boolean {
    return proto2.util.equals(ByteStreamWriterCloseRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamWriterCloseResponse
 */
export class ByteStreamWriterCloseResponse extends Message<ByteStreamWriterCloseResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<ByteStreamWriterCloseResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamWriterCloseResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamWriterCloseResponse {
    return new ByteStreamWriterCloseResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamWriterCloseResponse {
    return new ByteStreamWriterCloseResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamWriterCloseResponse {
    return new ByteStreamWriterCloseResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamWriterCloseResponse | PlainMessage<ByteStreamWriterCloseResponse> | undefined, b: ByteStreamWriterCloseResponse | PlainMessage<ByteStreamWriterCloseResponse> | undefined): boolean {
    return proto2.util.equals(ByteStreamWriterCloseResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.ByteStreamWriterCloseCallback
 */
export class ByteStreamWriterCloseCallback extends Message<ByteStreamWriterCloseCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from field: optional livekit.proto.StreamError error = 2;
   */
  error?: StreamError;

  constructor(data?: PartialMessage<ByteStreamWriterCloseCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamWriterCloseCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "error", kind: "message", T: StreamError, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamWriterCloseCallback {
    return new ByteStreamWriterCloseCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamWriterCloseCallback {
    return new ByteStreamWriterCloseCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamWriterCloseCallback {
    return new ByteStreamWriterCloseCallback().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamWriterCloseCallback | PlainMessage<ByteStreamWriterCloseCallback> | undefined, b: ByteStreamWriterCloseCallback | PlainMessage<ByteStreamWriterCloseCallback> | undefined): boolean {
    return proto2.util.equals(ByteStreamWriterCloseCallback, a, b);
  }
}

/**
 * @generated from message livekit.proto.OwnedTextStreamWriter
 */
export class OwnedTextStreamWriter extends Message<OwnedTextStreamWriter> {
  /**
   * @generated from field: required livekit.proto.FfiOwnedHandle handle = 1;
   */
  handle?: FfiOwnedHandle;

  /**
   * @generated from field: required livekit.proto.TextStreamInfo info = 2;
   */
  info?: TextStreamInfo;

  constructor(data?: PartialMessage<OwnedTextStreamWriter>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.OwnedTextStreamWriter";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "handle", kind: "message", T: FfiOwnedHandle, req: true },
    { no: 2, name: "info", kind: "message", T: TextStreamInfo, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OwnedTextStreamWriter {
    return new OwnedTextStreamWriter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OwnedTextStreamWriter {
    return new OwnedTextStreamWriter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OwnedTextStreamWriter {
    return new OwnedTextStreamWriter().fromJsonString(jsonString, options);
  }

  static equals(a: OwnedTextStreamWriter | PlainMessage<OwnedTextStreamWriter> | undefined, b: OwnedTextStreamWriter | PlainMessage<OwnedTextStreamWriter> | undefined): boolean {
    return proto2.util.equals(OwnedTextStreamWriter, a, b);
  }
}

/**
 * Opens an outgoing text stream.
 * Call must be balanced with a TextStreamCloseRequest.
 *
 * @generated from message livekit.proto.TextStreamOpenRequest
 */
export class TextStreamOpenRequest extends Message<TextStreamOpenRequest> {
  /**
   * @generated from field: required uint64 local_participant_handle = 1;
   */
  localParticipantHandle?: bigint;

  /**
   * Options to use for opening the stream.
   *
   * @generated from field: required livekit.proto.StreamTextOptions options = 2;
   */
  options?: StreamTextOptions;

  constructor(data?: PartialMessage<TextStreamOpenRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamOpenRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "local_participant_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "options", kind: "message", T: StreamTextOptions, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamOpenRequest {
    return new TextStreamOpenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamOpenRequest {
    return new TextStreamOpenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamOpenRequest {
    return new TextStreamOpenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamOpenRequest | PlainMessage<TextStreamOpenRequest> | undefined, b: TextStreamOpenRequest | PlainMessage<TextStreamOpenRequest> | undefined): boolean {
    return proto2.util.equals(TextStreamOpenRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamOpenResponse
 */
export class TextStreamOpenResponse extends Message<TextStreamOpenResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<TextStreamOpenResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamOpenResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamOpenResponse {
    return new TextStreamOpenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamOpenResponse {
    return new TextStreamOpenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamOpenResponse {
    return new TextStreamOpenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamOpenResponse | PlainMessage<TextStreamOpenResponse> | undefined, b: TextStreamOpenResponse | PlainMessage<TextStreamOpenResponse> | undefined): boolean {
    return proto2.util.equals(TextStreamOpenResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamOpenCallback
 */
export class TextStreamOpenCallback extends Message<TextStreamOpenCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from oneof livekit.proto.TextStreamOpenCallback.result
   */
  result: {
    /**
     * @generated from field: livekit.proto.OwnedTextStreamWriter writer = 2;
     */
    value: OwnedTextStreamWriter;
    case: "writer";
  } | {
    /**
     * @generated from field: livekit.proto.StreamError error = 3;
     */
    value: StreamError;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TextStreamOpenCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamOpenCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "writer", kind: "message", T: OwnedTextStreamWriter, oneof: "result" },
    { no: 3, name: "error", kind: "message", T: StreamError, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamOpenCallback {
    return new TextStreamOpenCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamOpenCallback {
    return new TextStreamOpenCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamOpenCallback {
    return new TextStreamOpenCallback().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamOpenCallback | PlainMessage<TextStreamOpenCallback> | undefined, b: TextStreamOpenCallback | PlainMessage<TextStreamOpenCallback> | undefined): boolean {
    return proto2.util.equals(TextStreamOpenCallback, a, b);
  }
}

/**
 * Writes text to a text stream writer.
 *
 * @generated from message livekit.proto.TextStreamWriterWriteRequest
 */
export class TextStreamWriterWriteRequest extends Message<TextStreamWriterWriteRequest> {
  /**
   * @generated from field: required uint64 writer_handle = 1;
   */
  writerHandle?: bigint;

  /**
   * @generated from field: required string text = 2;
   */
  text?: string;

  constructor(data?: PartialMessage<TextStreamWriterWriteRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamWriterWriteRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "writer_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamWriterWriteRequest {
    return new TextStreamWriterWriteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamWriterWriteRequest {
    return new TextStreamWriterWriteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamWriterWriteRequest {
    return new TextStreamWriterWriteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamWriterWriteRequest | PlainMessage<TextStreamWriterWriteRequest> | undefined, b: TextStreamWriterWriteRequest | PlainMessage<TextStreamWriterWriteRequest> | undefined): boolean {
    return proto2.util.equals(TextStreamWriterWriteRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamWriterWriteResponse
 */
export class TextStreamWriterWriteResponse extends Message<TextStreamWriterWriteResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<TextStreamWriterWriteResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamWriterWriteResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamWriterWriteResponse {
    return new TextStreamWriterWriteResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamWriterWriteResponse {
    return new TextStreamWriterWriteResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamWriterWriteResponse {
    return new TextStreamWriterWriteResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamWriterWriteResponse | PlainMessage<TextStreamWriterWriteResponse> | undefined, b: TextStreamWriterWriteResponse | PlainMessage<TextStreamWriterWriteResponse> | undefined): boolean {
    return proto2.util.equals(TextStreamWriterWriteResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamWriterWriteCallback
 */
export class TextStreamWriterWriteCallback extends Message<TextStreamWriterWriteCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from field: optional livekit.proto.StreamError error = 2;
   */
  error?: StreamError;

  constructor(data?: PartialMessage<TextStreamWriterWriteCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamWriterWriteCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "error", kind: "message", T: StreamError, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamWriterWriteCallback {
    return new TextStreamWriterWriteCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamWriterWriteCallback {
    return new TextStreamWriterWriteCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamWriterWriteCallback {
    return new TextStreamWriterWriteCallback().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamWriterWriteCallback | PlainMessage<TextStreamWriterWriteCallback> | undefined, b: TextStreamWriterWriteCallback | PlainMessage<TextStreamWriterWriteCallback> | undefined): boolean {
    return proto2.util.equals(TextStreamWriterWriteCallback, a, b);
  }
}

/**
 * Closes a text stream writer.
 *
 * @generated from message livekit.proto.TextStreamWriterCloseRequest
 */
export class TextStreamWriterCloseRequest extends Message<TextStreamWriterCloseRequest> {
  /**
   * @generated from field: required uint64 writer_handle = 1;
   */
  writerHandle?: bigint;

  /**
   * @generated from field: optional string reason = 2;
   */
  reason?: string;

  constructor(data?: PartialMessage<TextStreamWriterCloseRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamWriterCloseRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "writer_handle", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamWriterCloseRequest {
    return new TextStreamWriterCloseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamWriterCloseRequest {
    return new TextStreamWriterCloseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamWriterCloseRequest {
    return new TextStreamWriterCloseRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamWriterCloseRequest | PlainMessage<TextStreamWriterCloseRequest> | undefined, b: TextStreamWriterCloseRequest | PlainMessage<TextStreamWriterCloseRequest> | undefined): boolean {
    return proto2.util.equals(TextStreamWriterCloseRequest, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamWriterCloseResponse
 */
export class TextStreamWriterCloseResponse extends Message<TextStreamWriterCloseResponse> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  constructor(data?: PartialMessage<TextStreamWriterCloseResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamWriterCloseResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamWriterCloseResponse {
    return new TextStreamWriterCloseResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamWriterCloseResponse {
    return new TextStreamWriterCloseResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamWriterCloseResponse {
    return new TextStreamWriterCloseResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamWriterCloseResponse | PlainMessage<TextStreamWriterCloseResponse> | undefined, b: TextStreamWriterCloseResponse | PlainMessage<TextStreamWriterCloseResponse> | undefined): boolean {
    return proto2.util.equals(TextStreamWriterCloseResponse, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamWriterCloseCallback
 */
export class TextStreamWriterCloseCallback extends Message<TextStreamWriterCloseCallback> {
  /**
   * @generated from field: required uint64 async_id = 1;
   */
  asyncId?: bigint;

  /**
   * @generated from field: optional livekit.proto.StreamError error = 2;
   */
  error?: StreamError;

  constructor(data?: PartialMessage<TextStreamWriterCloseCallback>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamWriterCloseCallback";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "async_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, req: true },
    { no: 2, name: "error", kind: "message", T: StreamError, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamWriterCloseCallback {
    return new TextStreamWriterCloseCallback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamWriterCloseCallback {
    return new TextStreamWriterCloseCallback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamWriterCloseCallback {
    return new TextStreamWriterCloseCallback().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamWriterCloseCallback | PlainMessage<TextStreamWriterCloseCallback> | undefined, b: TextStreamWriterCloseCallback | PlainMessage<TextStreamWriterCloseCallback> | undefined): boolean {
    return proto2.util.equals(TextStreamWriterCloseCallback, a, b);
  }
}

/**
 * @generated from message livekit.proto.TextStreamInfo
 */
export class TextStreamInfo extends Message<TextStreamInfo> {
  /**
   * unique identifier for this data stream
   *
   * @generated from field: required string stream_id = 1;
   */
  streamId?: string;

  /**
   * using int64 for Unix timestamp
   *
   * @generated from field: required int64 timestamp = 2;
   */
  timestamp?: bigint;

  /**
   * @generated from field: required string mime_type = 3;
   */
  mimeType?: string;

  /**
   * @generated from field: required string topic = 4;
   */
  topic?: string;

  /**
   * only populated for finite streams, if it's a stream of unknown size this stays empty
   *
   * @generated from field: optional uint64 total_length = 5;
   */
  totalLength?: bigint;

  /**
   * user defined attributes map that can carry additional info
   *
   * @generated from field: map<string, string> attributes = 6;
   */
  attributes: { [key: string]: string } = {};

  /**
   * @generated from field: required livekit.proto.TextStreamInfo.OperationType operation_type = 7;
   */
  operationType?: TextStreamInfo_OperationType;

  /**
   * Optional: Version for updates/edits
   *
   * @generated from field: optional int32 version = 8;
   */
  version?: number;

  /**
   * Optional: Reply to specific message
   *
   * @generated from field: optional string reply_to_stream_id = 9;
   */
  replyToStreamId?: string;

  /**
   * file attachments for text streams
   *
   * @generated from field: repeated string attached_stream_ids = 10;
   */
  attachedStreamIds: string[] = [];

  /**
   * true if the text has been generated by an agent from a participant's audio transcription
   *
   * @generated from field: optional bool generated = 11;
   */
  generated?: boolean;

  /**
   * @generated from field: required livekit.proto.EncryptionType encryption_type = 12;
   */
  encryptionType?: EncryptionType;

  constructor(data?: PartialMessage<TextStreamInfo>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.TextStreamInfo";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 2, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */, req: true },
    { no: 3, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 4, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 5, name: "total_length", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 6, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "operation_type", kind: "enum", T: proto2.getEnumType(TextStreamInfo_OperationType), req: true },
    { no: 8, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 9, name: "reply_to_stream_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "attached_stream_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "generated", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 12, name: "encryption_type", kind: "enum", T: proto2.getEnumType(EncryptionType), req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextStreamInfo {
    return new TextStreamInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextStreamInfo {
    return new TextStreamInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextStreamInfo {
    return new TextStreamInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TextStreamInfo | PlainMessage<TextStreamInfo> | undefined, b: TextStreamInfo | PlainMessage<TextStreamInfo> | undefined): boolean {
    return proto2.util.equals(TextStreamInfo, a, b);
  }
}

/**
 * @generated from enum livekit.proto.TextStreamInfo.OperationType
 */
export enum TextStreamInfo_OperationType {
  /**
   * @generated from enum value: CREATE = 0;
   */
  CREATE = 0,

  /**
   * @generated from enum value: UPDATE = 1;
   */
  UPDATE = 1,

  /**
   * @generated from enum value: DELETE = 2;
   */
  DELETE = 2,

  /**
   * @generated from enum value: REACTION = 3;
   */
  REACTION = 3,
}
// Retrieve enum metadata with: proto2.getEnumType(TextStreamInfo_OperationType)
proto2.util.setEnumType(TextStreamInfo_OperationType, "livekit.proto.TextStreamInfo.OperationType", [
  { no: 0, name: "CREATE" },
  { no: 1, name: "UPDATE" },
  { no: 2, name: "DELETE" },
  { no: 3, name: "REACTION" },
]);

/**
 * @generated from message livekit.proto.ByteStreamInfo
 */
export class ByteStreamInfo extends Message<ByteStreamInfo> {
  /**
   * unique identifier for this data stream
   *
   * @generated from field: required string stream_id = 1;
   */
  streamId?: string;

  /**
   * using int64 for Unix timestamp
   *
   * @generated from field: required int64 timestamp = 2;
   */
  timestamp?: bigint;

  /**
   * @generated from field: required string mime_type = 3;
   */
  mimeType?: string;

  /**
   * @generated from field: required string topic = 4;
   */
  topic?: string;

  /**
   * only populated for finite streams, if it's a stream of unknown size this stays empty
   *
   * @generated from field: optional uint64 total_length = 5;
   */
  totalLength?: bigint;

  /**
   * user defined attributes map that can carry additional info
   *
   * @generated from field: map<string, string> attributes = 6;
   */
  attributes: { [key: string]: string } = {};

  /**
   * @generated from field: required string name = 7;
   */
  name?: string;

  /**
   * @generated from field: required livekit.proto.EncryptionType encryption_type = 8;
   */
  encryptionType?: EncryptionType;

  constructor(data?: PartialMessage<ByteStreamInfo>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.ByteStreamInfo";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 2, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */, req: true },
    { no: 3, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 4, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 5, name: "total_length", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 6, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 8, name: "encryption_type", kind: "enum", T: proto2.getEnumType(EncryptionType), req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ByteStreamInfo {
    return new ByteStreamInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ByteStreamInfo {
    return new ByteStreamInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ByteStreamInfo {
    return new ByteStreamInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ByteStreamInfo | PlainMessage<ByteStreamInfo> | undefined, b: ByteStreamInfo | PlainMessage<ByteStreamInfo> | undefined): boolean {
    return proto2.util.equals(ByteStreamInfo, a, b);
  }
}

/**
 * @generated from message livekit.proto.StreamTextOptions
 */
export class StreamTextOptions extends Message<StreamTextOptions> {
  /**
   * @generated from field: required string topic = 1;
   */
  topic?: string;

  /**
   * @generated from field: map<string, string> attributes = 2;
   */
  attributes: { [key: string]: string } = {};

  /**
   * @generated from field: repeated string destination_identities = 3;
   */
  destinationIdentities: string[] = [];

  /**
   * @generated from field: optional string id = 4;
   */
  id?: string;

  /**
   * @generated from field: optional livekit.proto.TextStreamInfo.OperationType operation_type = 5;
   */
  operationType?: TextStreamInfo_OperationType;

  /**
   * @generated from field: optional int32 version = 6;
   */
  version?: number;

  /**
   * @generated from field: optional string reply_to_stream_id = 7;
   */
  replyToStreamId?: string;

  /**
   * @generated from field: repeated string attached_stream_ids = 8;
   */
  attachedStreamIds: string[] = [];

  /**
   * @generated from field: optional bool generated = 9;
   */
  generated?: boolean;

  constructor(data?: PartialMessage<StreamTextOptions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamTextOptions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 2, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "destination_identities", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "operation_type", kind: "enum", T: proto2.getEnumType(TextStreamInfo_OperationType), opt: true },
    { no: 6, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "reply_to_stream_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "attached_stream_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "generated", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamTextOptions {
    return new StreamTextOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamTextOptions {
    return new StreamTextOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamTextOptions {
    return new StreamTextOptions().fromJsonString(jsonString, options);
  }

  static equals(a: StreamTextOptions | PlainMessage<StreamTextOptions> | undefined, b: StreamTextOptions | PlainMessage<StreamTextOptions> | undefined): boolean {
    return proto2.util.equals(StreamTextOptions, a, b);
  }
}

/**
 * @generated from message livekit.proto.StreamByteOptions
 */
export class StreamByteOptions extends Message<StreamByteOptions> {
  /**
   * @generated from field: required string topic = 1;
   */
  topic?: string;

  /**
   * @generated from field: map<string, string> attributes = 2;
   */
  attributes: { [key: string]: string } = {};

  /**
   * @generated from field: repeated string destination_identities = 3;
   */
  destinationIdentities: string[] = [];

  /**
   * @generated from field: optional string id = 4;
   */
  id?: string;

  /**
   * @generated from field: optional string name = 5;
   */
  name?: string;

  /**
   * @generated from field: optional string mime_type = 6;
   */
  mimeType?: string;

  /**
   * @generated from field: optional uint64 total_length = 7;
   */
  totalLength?: bigint;

  constructor(data?: PartialMessage<StreamByteOptions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamByteOptions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
    { no: 2, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "destination_identities", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "mime_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "total_length", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamByteOptions {
    return new StreamByteOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamByteOptions {
    return new StreamByteOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamByteOptions {
    return new StreamByteOptions().fromJsonString(jsonString, options);
  }

  static equals(a: StreamByteOptions | PlainMessage<StreamByteOptions> | undefined, b: StreamByteOptions | PlainMessage<StreamByteOptions> | undefined): boolean {
    return proto2.util.equals(StreamByteOptions, a, b);
  }
}

/**
 * Error pertaining to a stream.
 *
 * @generated from message livekit.proto.StreamError
 */
export class StreamError extends Message<StreamError> {
  /**
   * TODO(ladvoc): make this an enum.
   *
   * @generated from field: required string description = 1;
   */
  description?: string;

  constructor(data?: PartialMessage<StreamError>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "livekit.proto.StreamError";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, req: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamError {
    return new StreamError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamError {
    return new StreamError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamError {
    return new StreamError().fromJsonString(jsonString, options);
  }

  static equals(a: StreamError | PlainMessage<StreamError> | undefined, b: StreamError | PlainMessage<StreamError> | undefined): boolean {
    return proto2.util.equals(StreamError, a, b);
  }
}

